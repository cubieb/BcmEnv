/*
 * Note: this file originally auto-generated by mib2c using
 *    : mib2c.iterate.conf 17827 2009-11-20 16:18:11Z $
 */
#include "SystemInclude.h"
#include "BcmController.h"

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "Debug.h"
#include "ChannelMgt.h"
#include "docsIfUpstreamChannelTable.h"
using namespace std;

static CMCOAM_UsChannelCfgT usChannelCfg[BRCM_CMC_MAX_US_CH];

typedef int(*SnmpOperationHandler)(netsnmp_mib_handler*, netsnmp_handler_registration*,
                                   netsnmp_agent_request_info*, netsnmp_request_info*);

static int DocsIfUpChannelGet(netsnmp_mib_handler*, netsnmp_handler_registration*,
                              netsnmp_agent_request_info*, netsnmp_request_info*);
static int DocsIfUpChannelSetReserve1(netsnmp_mib_handler*,
                                      netsnmp_handler_registration*,
                                      netsnmp_agent_request_info*,
                                      netsnmp_request_info*);
static int DocsIfUpChannelSetReserve2(netsnmp_mib_handler*,
                                      netsnmp_handler_registration*,
                                      netsnmp_agent_request_info*,
                                      netsnmp_request_info*);
static int DocsIfUpChannelSetFree(netsnmp_mib_handler*,
                                  netsnmp_handler_registration*,
                                  netsnmp_agent_request_info*,
                                  netsnmp_request_info*);
static int DocsIfUpChannelSetAction(netsnmp_mib_handler*,
                                    netsnmp_handler_registration*,
                                    netsnmp_agent_request_info*,
                                    netsnmp_request_info*);
static int DocsIfUpChannelSetUndo(netsnmp_mib_handler*,
                                  netsnmp_handler_registration*,
                                  netsnmp_agent_request_info*,
                                  netsnmp_request_info*);
static int DocsIfUpChannelSetCommit(netsnmp_mib_handler*,
                                    netsnmp_handler_registration*,
                                    netsnmp_agent_request_info*,
                                    netsnmp_request_info*);

typedef void(*SnmpSetValueToPktHandler)(netsnmp_agent_request_info*,
                                   netsnmp_request_info*,
                                   CMCOAM_UsChannelCfgT*);
static void SnmpSetValueToReqestId(netsnmp_agent_request_info *reqInfo,
                                   netsnmp_request_info       *request,
                                   CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestFrequency(netsnmp_agent_request_info *reqInfo,
                                          netsnmp_request_info       *request,
                                          CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestWidth(netsnmp_agent_request_info *reqInfo,
                                      netsnmp_request_info       *request,
                                      CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestModulationProfile(netsnmp_agent_request_info *reqInfo,
                                                  netsnmp_request_info       *request,
                                                  CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestSlotSize(netsnmp_agent_request_info *reqInfo,
                                         netsnmp_request_info       *request,
                                         CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestTxTimingOffset (netsnmp_agent_request_info *reqInfo,
                                                netsnmp_request_info       *request,
                                                CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestRangingBackoffStart(netsnmp_agent_request_info *reqInfo,
                                                    netsnmp_request_info       *request,
                                                    CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestRangingBackOffend(netsnmp_agent_request_info *reqInfo,
                                                  netsnmp_request_info       *request,
                                                  CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestTxBackoffStart(netsnmp_agent_request_info *reqInfo,
                                               netsnmp_request_info       *request,
                                               CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestTxBackoffEnd(netsnmp_agent_request_info *reqInfo,
                                             netsnmp_request_info       *request,
                                             CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestScdmaActivecodes(netsnmp_agent_request_info *reqInfo,
                                                 netsnmp_request_info       *request,
                                                 CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestScdmaCodesperSlot(netsnmp_agent_request_info *reqInfo,
                                                  netsnmp_request_info       *request,
                                                  CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestScdmaFrameSize(netsnmp_agent_request_info *reqInfo,
                                               netsnmp_request_info       *request,
                                               CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestScdmaHoppingSeed(netsnmp_agent_request_info *reqInfo,
                                                 netsnmp_request_info       *request,
                                                 CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestType(netsnmp_agent_request_info *reqInfo,
                                     netsnmp_request_info       *request,
                                     CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestCloneFrom(netsnmp_agent_request_info *reqInfo,
                                          netsnmp_request_info       *request,
                                          CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestUpDate(netsnmp_agent_request_info *reqInfo,
                                       netsnmp_request_info       *request,
                                       CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestStatus(netsnmp_agent_request_info *reqInfo,
                                       netsnmp_request_info       *request,
                                       CMCOAM_UsChannelCfgT       *entry);
static void SnmpSetValueToReqestPreeqEnable(netsnmp_agent_request_info *reqInfo,
                                            netsnmp_request_info       *request,
                                            CMCOAM_UsChannelCfgT       *entry);

static map<int, SnmpOperationHandler> snmpHandler;
static map<int, SnmpSetValueToPktHandler>  snmpSetValueHandler;

void InitDocsIfUpChannelTable(void)
{
    const oid    tableOid[] = {1,3,6,1,2,1,10,127,1,1,2};
    const size_t oidLen     = OID_LENGTH(tableOid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;

    reg = netsnmp_create_handler_registration("docsIfUpstreamChannelTable",
                                              DocsIfUpChannelHandler,
                                              tableOid,
                                              oidLen,
                                              HANDLER_CAN_RWRITE);

    netsnmp_table_registration_info *tableInfo;
    tableInfo = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(tableInfo,
                                     ASN_INTEGER,  /* index: ifIndex */
                                     0);
    tableInfo->min_column = ColumnDocsIfUpChannelId;
    tableInfo->max_column = ColumnDocsIfUpChannelPreeqEnable;

    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = DocsIfUpChannelGetFirst;
    iinfo->get_next_data_point  = DocsIfUpChannelGetNext;
    iinfo->table_reginfo        = tableInfo;

    netsnmp_register_table_iterator(reg, iinfo);

    /* Initialize the contents of the table here */
    snmpHandler.insert(make_pair(MODE_GET, DocsIfUpChannelGet));
    snmpHandler.insert(make_pair(MODE_SET_RESERVE1, DocsIfUpChannelSetReserve1));
    snmpHandler.insert(make_pair(MODE_SET_RESERVE2, DocsIfUpChannelSetReserve2));
    snmpHandler.insert(make_pair(MODE_SET_FREE, DocsIfUpChannelSetFree));
    snmpHandler.insert(make_pair(MODE_SET_ACTION, DocsIfUpChannelSetAction));
    snmpHandler.insert(make_pair(MODE_SET_UNDO, DocsIfUpChannelSetUndo));
    snmpHandler.insert(make_pair(MODE_SET_COMMIT, DocsIfUpChannelSetCommit));

    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelId, SnmpSetValueToReqestId));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIFUpChannelFrequency, SnmpSetValueToReqestFrequency));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelWidth, SnmpSetValueToReqestWidth));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelModulationProfile, SnmpSetValueToReqestModulationProfile));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelSlotSize, SnmpSetValueToReqestSlotSize));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelTxTimingOffset, SnmpSetValueToReqestTxTimingOffset));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelRangingBackoffStart, SnmpSetValueToReqestRangingBackoffStart));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelRangingBackOffend, SnmpSetValueToReqestRangingBackOffend));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelTxBackoffStart, SnmpSetValueToReqestTxBackoffStart));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelTxBackoffEnd, SnmpSetValueToReqestTxBackoffEnd));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelScdmaActivecodes, SnmpSetValueToReqestScdmaActivecodes));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelScdmaCodesperSlot, SnmpSetValueToReqestScdmaCodesperSlot));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelScdmaFrameSize, SnmpSetValueToReqestScdmaFrameSize));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelScdmaHoppingSeed, SnmpSetValueToReqestScdmaHoppingSeed));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelType, SnmpSetValueToReqestType));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelCloneFrom, SnmpSetValueToReqestCloneFrom));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelUpDate, SnmpSetValueToReqestUpDate));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelStatus, SnmpSetValueToReqestStatus));
    snmpSetValueHandler.insert(make_pair(ColumnDocsIfUpChannelPreeqEnable, SnmpSetValueToReqestPreeqEnable));
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list* DocsIfUpChannelGetFirst(void **loopContext,
                                                void **dataContext,
                                                netsnmp_variable_list *indexData,
                                                netsnmp_iterator_info *data)
{
    dbgstrm << "Start." << endl;
    CMCOAM_UsChannelCfgT cfg, *i = usChannelCfg;
    BASE_ErrCode ret;

    for (ret = MgtChannelGetFirstUpstreamSettings(&cfg);
         ret == BASE_OK;
         ret = MgtChannelGetNextUpstreamSettings(&cfg, &cfg))
    {
        memcpy(i++, &cfg, sizeof(CMCOAM_UsChannelCfgT));
    }

    *loopContext = usChannelCfg;
    return DocsIfUpChannelGetNext(loopContext, dataContext, indexData,  data);
}

/* The GetNext() function is called by net-snmp library to iterate all table index,
 * terminate loop by return NULL.
 */
netsnmp_variable_list* DocsIfUpChannelGetNext(void **loopContext,
                                              void **dataContext,
                                              netsnmp_variable_list *indexData,
                                              netsnmp_iterator_info *data)
{
    dbgstrm << "Start." << endl;
    CMCOAM_UsChannelCfgT *cfg = (CMCOAM_UsChannelCfgT *)*loopContext;
    if (cfg < usChannelCfg + BRCM_CMC_MAX_US_CH)
    {
        snmp_set_var_value(indexData, &cfg->us_ch_id, sizeof(uint8_t));
        *dataContext = cfg++;
        *loopContext = cfg;
        return indexData;
    }

    *loopContext = NULL;
    *dataContext = NULL;
    return NULL;
}

/* The GetNext() function is called by net-snmp library to iterate all table index,
 * terminate loop by return NULL.
 */
void SnmpSetValueToReqestId(netsnmp_agent_request_info *reqInfo,
                            netsnmp_request_info       *request,
                            CMCOAM_UsChannelCfgT       *entry)
{
    dbgstrm << "Start." << endl;
    int32_t value = entry->us_ch_id;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(int32_t));
}

void SnmpSetValueToReqestFrequency(netsnmp_agent_request_info *reqInfo,
                                   netsnmp_request_info       *request,
                                   CMCOAM_UsChannelCfgT       *entry)
{
    dbgstrm << "Start." << endl;
    int32_t value = entry->freq;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(int32_t));
}

void SnmpSetValueToReqestWidth(netsnmp_agent_request_info *reqInfo,
                               netsnmp_request_info       *request,
                               CMCOAM_UsChannelCfgT       *entry)
{
    dbgstrm << "Start." << endl;
    int32_t value = entry->width;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(int32_t));
}

void SnmpSetValueToReqestModulationProfile(netsnmp_agent_request_info *reqInfo,
                                           netsnmp_request_info       *request,
                                           CMCOAM_UsChannelCfgT       *entry)
{
    uint32_t value = entry->profile_type;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(uint32_t));
}

void SnmpSetValueToReqestSlotSize(netsnmp_agent_request_info *reqInfo,
                                  netsnmp_request_info       *request,
                                  CMCOAM_UsChannelCfgT       *entry)
{
    uint32_t value = entry->minislot_size;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(uint32_t));
}

void SnmpSetValueToReqestTxTimingOffset (netsnmp_agent_request_info *reqInfo,
                                         netsnmp_request_info       *request,
                                         CMCOAM_UsChannelCfgT       *entry)
{
    uint32_t value = entry->trsmit_time_offset;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(uint32_t));
}

void SnmpSetValueToReqestRangingBackoffStart(netsnmp_agent_request_info *reqInfo,
                                             netsnmp_request_info       *request,
                                             CMCOAM_UsChannelCfgT       *entry)
{
    int32_t value = entry->initRNG_win;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(int32_t));
}

void SnmpSetValueToReqestRangingBackOffend(netsnmp_agent_request_info *reqInfo,
                                           netsnmp_request_info       *request,
                                           CMCOAM_UsChannelCfgT       *entry)
{
    int32_t value = entry->finRNG_win;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(int32_t));
}

void SnmpSetValueToReqestTxBackoffStart(netsnmp_agent_request_info *reqInfo,
                                        netsnmp_request_info       *request,
                                        CMCOAM_UsChannelCfgT       *entry)
{
    int32_t value = entry->initData_win;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(int32_t));
}

void SnmpSetValueToReqestTxBackoffEnd(netsnmp_agent_request_info *reqInfo,
                                      netsnmp_request_info       *request,
                                      CMCOAM_UsChannelCfgT       *entry)
{
    int32_t value = entry->finData_win;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(int32_t));
}

void SnmpSetValueToReqestScdmaActivecodes(netsnmp_agent_request_info *reqInfo,
                                          netsnmp_request_info       *request,
                                          CMCOAM_UsChannelCfgT       *entry)
{
    uint32_t value = entry->scdma_code;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(uint32_t));
}

void SnmpSetValueToReqestScdmaCodesperSlot(netsnmp_agent_request_info *reqInfo,
                                           netsnmp_request_info       *request,
                                           CMCOAM_UsChannelCfgT       *entry)
{
    int32_t value = entry->scdma_code_per_minislot;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(int32_t));
}

void SnmpSetValueToReqestScdmaFrameSize(netsnmp_agent_request_info *reqInfo,
                                        netsnmp_request_info       *request,
                                        CMCOAM_UsChannelCfgT       *entry)
{
    uint32_t value = entry->scdma_frm_size;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(uint32_t));
}

void SnmpSetValueToReqestScdmaHoppingSeed(netsnmp_agent_request_info *reqInfo,
                                          netsnmp_request_info       *request,
                                          CMCOAM_UsChannelCfgT       *entry)
{
    uint32_t value = entry->scdma_frm_size;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(uint32_t));
}

void SnmpSetValueToReqestType(netsnmp_agent_request_info *reqInfo,
                              netsnmp_request_info       *request,
                              CMCOAM_UsChannelCfgT       *entry)
{
    int32_t value = entry->mode;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(int32_t));
}

void SnmpSetValueToReqestCloneFrom(netsnmp_agent_request_info *reqInfo,
                                   netsnmp_request_info       *request,
                                   CMCOAM_UsChannelCfgT       *entry)
{
    int32_t value = 0;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(int32_t));
}

void SnmpSetValueToReqestUpDate(netsnmp_agent_request_info *reqInfo,
                                netsnmp_request_info       *request,
                                CMCOAM_UsChannelCfgT       *entry)
{
    int32_t value = 1;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(int32_t));
}

void SnmpSetValueToReqestStatus(netsnmp_agent_request_info *reqInfo,
                                netsnmp_request_info       *request,
                                CMCOAM_UsChannelCfgT       *entry)
{
    int32_t value = 0;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(int32_t));
}

void SnmpSetValueToReqestPreeqEnable(netsnmp_agent_request_info *reqInfo,
                                     netsnmp_request_info       *request,
                                     CMCOAM_UsChannelCfgT       *entry)
{
    int32_t value = 1;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &value, sizeof(int32_t));
}

int DocsIfUpChannelGet(netsnmp_mib_handler               *handler,
                       netsnmp_handler_registration      *regInfo,
                       netsnmp_agent_request_info        *reqInfo,
                       netsnmp_request_info              *requests)
{
    netsnmp_request_info       *request;
    netsnmp_table_request_info *tableInfo;
    CMCOAM_UsChannelCfgT* entry;

    dbgstrm << "Start." << endl;
    for (request=requests; request; request=request->next)
    {
        dbgstrm << "...." << endl;
        entry = (CMCOAM_UsChannelCfgT*)netsnmp_extract_iterator_context(request);
        if (entry == NULL)
        {
            dbgstrm << "entry is NULL" << endl;
            netsnmp_set_request_error(reqInfo, request, SNMP_NOSUCHINSTANCE);
            continue;
        }
        tableInfo  = netsnmp_extract_table_info(request);

        map<int, SnmpSetValueToPktHandler>::iterator iter;
        iter = snmpSetValueHandler.find(tableInfo->colnum);
        if(iter != snmpSetValueHandler.end())
            iter->second(reqInfo, requests, entry);
        else
        {
            dbgstrm << "Error, wrong table column number";
            netsnmp_set_request_error(reqInfo, request, SNMP_NOSUCHOBJECT);
        }
    }

    return SNMP_ERR_NOERROR;
}

int DocsIfUpChannelSetReserve1(netsnmp_mib_handler               *handler,
                               netsnmp_handler_registration      *regInfo,
                               netsnmp_agent_request_info        *reqInfo,
                               netsnmp_request_info              *requests)
{
    dbgstrm << "Start." << endl;
    return SNMP_ERR_NOERROR;
}

/* MODE_SET_RESERVE2:
 *    When create new entry, this function allocate resource for new entry.
 *    When modify or query entry,  do nothing.
 */
int DocsIfUpChannelSetReserve2(netsnmp_mib_handler               *handler,
                               netsnmp_handler_registration      *regInfo,
                               netsnmp_agent_request_info        *reqInfo,
                               netsnmp_request_info              *requests)
{
    dbgstrm << "Start." << endl;
    return SNMP_ERR_NOERROR;
}

int DocsIfUpChannelSetFree(netsnmp_mib_handler               *handler,
                            netsnmp_handler_registration      *regInfo,
                            netsnmp_agent_request_info        *reqInfo,
                            netsnmp_request_info              *requests)
{
    dbgstrm << "Start." << endl;
    return SNMP_ERR_NOERROR;
}

/*
 * When modify table,  the program flow is:
 *      SetReserve1()
 *      SetReserve2()
 *      SetAction()
 *      SetCommit()
 */
int DocsIfUpChannelSetCommit(netsnmp_mib_handler               *handler,
                             netsnmp_handler_registration      *regInfo,
                             netsnmp_agent_request_info        *reqInfo,
                             netsnmp_request_info              *requests)
{
    netsnmp_request_info       *request;
    netsnmp_table_request_info *tableInfo;
    CMCOAM_UsChannelCfgT* entry;

    dbgstrm << "Start." << endl;
    for (request=requests; request; request=request->next)
    {
        dbgstrm << "..." << endl;
        entry = (CMCOAM_UsChannelCfgT*)netsnmp_extract_iterator_context(request);
        tableInfo = netsnmp_extract_table_info(request);
        if (entry == NULL)
        {
            errstrm << "entry is NULL. " << endl;
            break;
        }

        switch (tableInfo->colnum)
        {
        case ColumnDocsIFUpChannelFrequency:
            MgtChannelSetDownstreamSettingsFreq(entry->us_ch_id, *request->requestvb->val.integer);
            break;

        case ColumnDocsIfUpChannelWidth:
            MgtChannelSetUpstreamSettingsChannelWidth(entry->us_ch_id, *request->requestvb->val.integer);
            break;

        case ColumnDocsIfUpChannelModulationProfile:
            MgtChannelSetUpstreamSettingsChannelProfile(entry->us_ch_id, *(uint32_t*)request->requestvb->val.integer);
            break;

        /* Read only data member. */
        case ColumnDocsIfUpChannelSlotSize:
        case ColumnDocsIfUpChannelTxTimingOffset:
        case ColumnDocsIfUpChannelRangingBackoffStart:
        case ColumnDocsIfUpChannelRangingBackOffend:
        case ColumnDocsIfUpChannelTxBackoffStart:
        case ColumnDocsIfUpChannelTxBackoffEnd:
        case ColumnDocsIfUpChannelScdmaActivecodes:
        case ColumnDocsIfUpChannelScdmaCodesperSlot:
        case ColumnDocsIfUpChannelScdmaFrameSize:
        case ColumnDocsIfUpChannelScdmaHoppingSeed:
        case ColumnDocsIfUpChannelType:
        case ColumnDocsIfUpChannelCloneFrom:
        case ColumnDocsIfUpChannelUpDate:
        case ColumnDocsIfUpChannelStatus:
        case ColumnDocsIfUpChannelPreeqEnable:
        default:
            break;
        }
    }

    dbgstrm << "end." << endl;
    return SNMP_ERR_NOERROR;
}

int DocsIfUpChannelSetAction(netsnmp_mib_handler               *handler,
                             netsnmp_handler_registration      *regInfo,
                             netsnmp_agent_request_info        *reqInfo,
                             netsnmp_request_info              *requests)
{
    dbgstrm << "Start." << endl;
    return SNMP_ERR_NOERROR;
}

int DocsIfUpChannelSetUndo(netsnmp_mib_handler               *handler,
                           netsnmp_handler_registration      *regInfo,
                           netsnmp_agent_request_info        *reqInfo,
                           netsnmp_request_info              *requests)
{
    dbgstrm << "Start." << endl;
    return SNMP_ERR_NOERROR;
}

/** handles requests for the netSnmpIETFWGTable table */
int DocsIfUpChannelHandler(netsnmp_mib_handler               *handler,
                           netsnmp_handler_registration      *regInfo,
                           netsnmp_agent_request_info        *reqInfo,
                           netsnmp_request_info              *requests)
{
    map<int, SnmpOperationHandler>::iterator iter;
    iter = snmpHandler.find(reqInfo->mode);
    assert(iter != snmpHandler.end());
    iter->second(handler, regInfo, reqInfo, requests);

    return SNMP_ERR_NOERROR;
}

