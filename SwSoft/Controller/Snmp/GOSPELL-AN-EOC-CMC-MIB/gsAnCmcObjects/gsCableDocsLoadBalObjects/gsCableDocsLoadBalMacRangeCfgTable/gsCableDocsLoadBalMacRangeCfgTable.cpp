/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 17695 2009-07-21 12:22:18Z dts12 $
 */
#include "SystemInclude.h"
#include "BcmController.h"

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "Debug.h"
#include "LoadBalanceMgt.h"
#include "gsCableDocsLoadBalMacRangeCfgTable.h"
using namespace std;

typedef int(*SnmpOperationHandler)(netsnmp_mib_handler*,
                                   netsnmp_handler_registration*,
                                   netsnmp_agent_request_info*,
                                   netsnmp_request_info*);

static int DocsLoadBalMacRangeCfgGet(netsnmp_mib_handler*, netsnmp_handler_registration*,
                                netsnmp_agent_request_info*, netsnmp_request_info*);
static int DocsLoadBalMacRangeCfgSetReserve1(netsnmp_mib_handler*,
                                        netsnmp_handler_registration*,
                                        netsnmp_agent_request_info*,
                                        netsnmp_request_info*);
static int DocsLoadBalMacRangeCfgSetReserve2(netsnmp_mib_handler*,
                                        netsnmp_handler_registration*,
                                        netsnmp_agent_request_info*,
                                        netsnmp_request_info*);
static int DocsLoadBalMacRangeCfgSetFree(netsnmp_mib_handler*,
                                    netsnmp_handler_registration*,
                                    netsnmp_agent_request_info*,
                                    netsnmp_request_info*);
static int DocsLoadBalMacRangeCfgSetAction(netsnmp_mib_handler*,
                                      netsnmp_handler_registration*,
                                      netsnmp_agent_request_info*,
                                      netsnmp_request_info*);
static int DocsLoadBalMacRangeCfgSetUndo(netsnmp_mib_handler*,
                                    netsnmp_handler_registration*,
                                    netsnmp_agent_request_info*,
                                    netsnmp_request_info*);
static int DocsLoadBalMacRangeCfgSetCommit(netsnmp_mib_handler*,
                                      netsnmp_handler_registration*,
                                      netsnmp_agent_request_info*,
                                      netsnmp_request_info*);

typedef void(*SnmpSetValueToPktHandler)(netsnmp_agent_request_info*,
                                        netsnmp_request_info*,
                                        int32_t);

static void SnmpSetValueToReqestGrpCfgId(netsnmp_agent_request_info *reqInfo,
                                         netsnmp_request_info       *request,
                                         int32_t                    index);
static void SnmpSetValueToReqestIndex(netsnmp_agent_request_info *reqInfo,
                                      netsnmp_request_info       *request,
                                      int32_t                    index);
static void SnmpSetValueToReqestStartMac(netsnmp_agent_request_info *reqInfo,
                                         netsnmp_request_info       *request,
                                         int32_t                    index);
static void SnmpSetValueToReqestEndMac(netsnmp_agent_request_info *reqInfo,
                                       netsnmp_request_info       *request,
                                       int32_t                    index);
static void SnmpSetValueToReqestOption(netsnmp_agent_request_info *reqInfo,
                                       netsnmp_request_info       *request,
                                       int32_t                    index);

static map<int, SnmpOperationHandler> snmpHandler;
static map<int, SnmpSetValueToPktHandler>  snmpSetValueHandler;

static int32_t MakeSnmpTableIndex(int32_t grpId, int32_t macRangeIndex)
{
    return grpId * 1000 + macRangeIndex;
}

static int32_t GetSnmpGrpId(int32_t tableIndex)
{
    return tableIndex / 1000;
}

static int32_t GetSnmpMacRangeIndex(int32_t tableIndex)
{
    return tableIndex % 1000;
}

/** Initializes the docsIfDownstreamChannelTable module */
void InitDocsLoadBalMacRangeCfgTable(void)
{
  /* here we initialize all the tables we're planning on supporting */
    const oid    tableOid[] = {1,3,6,1,4,1,22764,1015,9026,2,4,3};
    const size_t oidLen     = OID_LENGTH(tableOid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;

    reg = netsnmp_create_handler_registration("gsCableDocsLoadBalMacRangeCfgTable",
                                              DocsLoadBalMacRangeCfgHandler,
                                              tableOid, oidLen,
                                              HANDLER_CAN_RWRITE);

    netsnmp_table_registration_info *tableInfo;
    tableInfo = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(tableInfo,
                                     ASN_INTEGER,  /* index: Group Id */
                                     ASN_INTEGER,  /* index: Mac Range Index */
                                     0);
    tableInfo->min_column = ColumnGsCableDocsLoadBalMacRangeGrpCfgId;
    tableInfo->max_column = ColumnGsCableDocsLoadBalMacRangeCfgOption;

    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = DocsLoadBalMacRangeCfgGetFirst;
    iinfo->get_next_data_point  = DocsLoadBalMacRangeCfgGetNext;
    iinfo->table_reginfo        = tableInfo;

    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialize the contents of the table here */
    snmpHandler.insert(make_pair(MODE_GET, DocsLoadBalMacRangeCfgGet));
    snmpHandler.insert(make_pair(MODE_SET_RESERVE1, DocsLoadBalMacRangeCfgSetReserve1));
    snmpHandler.insert(make_pair(MODE_SET_RESERVE2, DocsLoadBalMacRangeCfgSetReserve2));
    snmpHandler.insert(make_pair(MODE_SET_FREE, DocsLoadBalMacRangeCfgSetFree));
    snmpHandler.insert(make_pair(MODE_SET_ACTION, DocsLoadBalMacRangeCfgSetAction));
    snmpHandler.insert(make_pair(MODE_SET_UNDO, DocsLoadBalMacRangeCfgSetUndo));
    snmpHandler.insert(make_pair(MODE_SET_COMMIT, DocsLoadBalMacRangeCfgSetCommit));

    snmpSetValueHandler.insert(make_pair(ColumnGsCableDocsLoadBalMacRangeGrpCfgId, SnmpSetValueToReqestGrpCfgId));
    snmpSetValueHandler.insert(make_pair(ColumnGsCableDocsLoadBalMacRangeCfgIndex, SnmpSetValueToReqestIndex));
    snmpSetValueHandler.insert(make_pair(ColumnGsCableDocsLoadBalMacRangeCfgStartMac, SnmpSetValueToReqestStartMac));
    snmpSetValueHandler.insert(make_pair(ColumnGsCableDocsLoadBalMacRangeCfgEndMac, SnmpSetValueToReqestEndMac));
    snmpSetValueHandler.insert(make_pair(ColumnGsCableDocsLoadBalMacRangeCfgOption, SnmpSetValueToReqestOption));
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list* DocsLoadBalMacRangeCfgGetFirst(void **loopContext,
                                                      void **dataContext,
                                                      netsnmp_variable_list *indexData,
                                                      netsnmp_iterator_info *data)
{
    BASE_ErrCode   errCode;
    LoadBalGrpCfgT grp;

    dbgstrm << "Start." << endl;

    for(errCode = GetFirstLoadBalanceGrp(&grp, cliGetCmc());
        errCode == BASE_OK;
        errCode = GetNextLoadBalanceGrp(grp.id, &grp, cliGetCmc()))
    {
        if (grp.macRangeNum == 0)
        {
            continue;
        }

        int32_t value = MacRangeStartIndex;
        snmp_set_var_value(indexData, &grp.id, sizeof(int32_t));
        snmp_set_var_value(indexData->next_variable, &value, sizeof(int32_t));

        value = MakeSnmpTableIndex(grp.id, MacRangeStartIndex);
        *dataContext = (void *)value;
        *loopContext = (void *)value;
        return indexData;
    }

    *dataContext = NULL;
    *loopContext = NULL;
    return NULL;
}

/* The GetNext() function is called by net-snmp library to iterate all table index,
 * terminate loop by return NULL.
 */
netsnmp_variable_list* DocsLoadBalMacRangeCfgGetNext(void **loopContext,
                                                     void **dataContext,
                                                     netsnmp_variable_list *indexData,
                                                     netsnmp_iterator_info *data)
{
    BASE_ErrCode errCode;
    LoadBalGrpCfgT grp;

    int32_t index = (int32_t)(*loopContext);
    int32_t grpId = GetSnmpGrpId(index);
    int32_t macRangeIndex = GetSnmpMacRangeIndex(index) + 1;

    dbgstrm << "Start. grpId = " << grpId
            << ", macRangeIndex = " << macRangeIndex
            << endl;
    for(errCode = FindLoadBalanceGrp(grpId, &grp, cliGetCmc());
        errCode == BASE_OK;
        errCode = GetNextLoadBalanceGrp(grp.id, &grp, cliGetCmc()))
    {
        dbgstrm << grp << endl;
        if (macRangeIndex <= (int32_t)grp.macRangeNum)
        {
            dbgstrm << "OK, grpId = " << grp.id
                    << ", mac index = " << macRangeIndex << endl;

            snmp_set_var_value(indexData, &grp.id, sizeof(int32_t));
            snmp_set_var_value(indexData->next_variable, &macRangeIndex, sizeof(int32_t));

            index = MakeSnmpTableIndex(grp.id, macRangeIndex);
            *dataContext = (void *)index;
            *loopContext = (void *)index;

            return indexData;
        }

        dbgstrm << "Not OK, find next group." << endl;
        macRangeIndex = MacRangeStartIndex;
    }

    dbgstrm << "Not existed." << endl;
    *dataContext = NULL;
    *loopContext = NULL;
    return NULL;
}

void SnmpSetValueToReqestGrpCfgId(netsnmp_agent_request_info *reqInfo,
                                  netsnmp_request_info       *request,
                                  int32_t                    index)
{
    dbgstrm << "Start, index = " << index << endl;
    int32_t grpId = GetSnmpGrpId(index);
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &grpId, sizeof(int32_t));
}

void SnmpSetValueToReqestIndex(netsnmp_agent_request_info *reqInfo,
                              netsnmp_request_info       *request,
                              int32_t                    index)
{
    int32_t macRangeIndex = GetSnmpMacRangeIndex(index);

    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &macRangeIndex, sizeof(int32_t));
}

void SnmpSetValueToReqestStartMac(netsnmp_agent_request_info *reqInfo,
                                  netsnmp_request_info       *request,
                                  int32_t                    index)
{
    int32_t grpId = GetSnmpGrpId(index);
    int32_t macRangeIndex = GetSnmpMacRangeIndex(index);

    LoadBalGrpCfgT grp;
    BASE_ErrCode errCode = FindLoadBalanceGrp(grpId, &grp, cliGetCmc());
    if (errCode != BASE_OK || macRangeIndex > grp.macRangeNum)
    {
        netsnmp_set_request_error(reqInfo, request, SNMP_NOSUCHINSTANCE);
        return;
    }

    snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                             grp.macRange[macRangeIndex - 1].start,
                             6);
}

void SnmpSetValueToReqestEndMac(netsnmp_agent_request_info *reqInfo,
                                  netsnmp_request_info       *request,
                                  int32_t                    index)
{
    int32_t grpId = GetSnmpGrpId(index);
    int32_t macRangeIndex = GetSnmpMacRangeIndex(index);

    LoadBalGrpCfgT grp;
    BASE_ErrCode errCode = FindLoadBalanceGrp(grpId, &grp, cliGetCmc());
    if (errCode != BASE_OK || macRangeIndex > grp.macRangeNum)
    {
        netsnmp_set_request_error(reqInfo, request, SNMP_NOSUCHINSTANCE);
        return;
    }

    snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                             grp.macRange[macRangeIndex - 1].end,
                             6);
}

void SnmpSetValueToReqestOption(netsnmp_agent_request_info *reqInfo,
                                netsnmp_request_info       *request,
                                int32_t                    index)
{
    int32_t option = 0;
    snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                             &option, sizeof(int32_t));
}

int DocsLoadBalMacRangeCfgGet(netsnmp_mib_handler               *handler,
                              netsnmp_handler_registration      *regInfo,
                              netsnmp_agent_request_info        *reqInfo,
                              netsnmp_request_info              *requests)
{
    netsnmp_request_info       *request;
    netsnmp_table_request_info *tableInfo;

    dbgstrm << "Start." << endl;
    for (request=requests; request; request=request->next)
    {
        int32_t index = (int32_t)netsnmp_extract_iterator_context(request);
        dbgstrm << "index = " << index << endl;

        if ((void *)index == NULL)
        {
            dbgstrm << "entry is NULL" << endl;
            netsnmp_set_request_error(reqInfo, request, SNMP_NOSUCHINSTANCE);
            continue;
        }
        tableInfo  = netsnmp_extract_table_info(request);

        map<int, SnmpSetValueToPktHandler>::iterator iter;
        iter = snmpSetValueHandler.find(tableInfo->colnum);
        if(iter != snmpSetValueHandler.end())
        {
            iter->second(reqInfo, requests, index);
        }
        else
        {
            dbgstrm << "Error, wrong table column number";
            netsnmp_set_request_error(reqInfo, request, SNMP_NOSUCHINSTANCE);
        }
    }

    return SNMP_ERR_NOERROR;
}

int DocsLoadBalMacRangeCfgSetReserve1(netsnmp_mib_handler               *handler,
                                      netsnmp_handler_registration      *regInfo,
                                      netsnmp_agent_request_info        *reqInfo,
                                      netsnmp_request_info              *requests)
{
    dbgstrm << "Start." << endl;
    return SNMP_ERR_NOERROR;
}

/* MODE_SET_RESERVE2:
 *    When create new entry, this function allocate resource for new entry.
 *    When modify or query entry,  do nothing.
 * Refer to net-snmp example codes "mteTriggerTable.c" for "mteTriggerTable"
 * of DISMAN-EVENT-MIB.
 */
int DocsLoadBalMacRangeCfgSetReserve2(netsnmp_mib_handler               *handler,
                                      netsnmp_handler_registration      *regInfo,
                                      netsnmp_agent_request_info        *reqInfo,
                                      netsnmp_request_info              *requests)
{
    netsnmp_request_info       *request;
    netsnmp_table_request_info *tableInfo;

    BASE_ErrCode errCode;
    MacAddressT mac = {{0xff, 0xff, 0xff, 0xff, 0xff, 0xff}};

    dbgstrm << "Start." << endl;
    for (request = requests; request; request = request->next)
    {
        int32_t index;
        int32_t grpId;
        int32_t macRangeIndex;

        tableInfo = netsnmp_extract_table_info(request);
        switch(tableInfo->colnum)
        {
        case ColumnGsCableDocsLoadBalMacRangeCfgOption:
            /*
             * Create an (empty) new row structure
             */
            switch (*request->requestvb->val.integer)
            {
            case RowStatusCreate:
                /* Note: this index is not content of table.  It is the "Instance" field
                 *       in MIB-Browser.
                 */
                grpId = *tableInfo->indexes->val.integer;
                macRangeIndex = *tableInfo->indexes->next_variable->val.integer;
                errCode = AddCnuRangeToLoadBalanceGrp(grpId, &mac, &mac, cliGetCmc());
                if (errCode != BASE_OK)
                {
                    cerr << "Can't create MAC range, index = " << index << endl;
                    netsnmp_set_request_error(reqInfo, request, SNMP_ERR_BADVALUE);
                    return SNMP_ERR_NOERROR;
                }

                index = MakeSnmpTableIndex(grpId, macRangeIndex);
                netsnmp_insert_iterator_context(request, (void *)index);
                break;

            default:
                break;
            }
            break;

        default:
            break;
        }
    }
    return SNMP_ERR_NOERROR;
}

int DocsLoadBalMacRangeCfgSetFree(netsnmp_mib_handler               *handler,
                                  netsnmp_handler_registration      *regInfo,
                                  netsnmp_agent_request_info        *reqInfo,
                                  netsnmp_request_info              *requests)
{
    dbgstrm << "Start." << endl;
    return SNMP_ERR_NOERROR;
}

/*
 * When modify table,  the program flow is:
 *      SetReserve1()
 *      SetReserve2()
 *      SetAction()
 *      SetCommit()
 * net-snmp will call this function for every modification separately,
 * so we can't commit once for all modification, we can only call
 * SetFullLoadBalancingGrp() immediately for every field in requests loop.
 */
int DocsLoadBalMacRangeCfgSetCommit(netsnmp_mib_handler               *handler,
                                    netsnmp_handler_registration      *regInfo,
                                    netsnmp_agent_request_info        *reqInfo,
                                    netsnmp_request_info              *requests)
{
    netsnmp_request_info       *request;
    netsnmp_table_request_info *tableInfo;

    dbgstrm << "Start." << endl;
    for (request=requests; request; request=request->next)
    {
        int32_t index = (int32_t)netsnmp_extract_iterator_context(request);
        int32_t grpId = GetSnmpGrpId(index);
        int32_t macRangeIndex = GetSnmpMacRangeIndex(index);

        dbgstrm << "index = " << index << endl;
        LoadBalGrpCfgT grp;
        BASE_ErrCode errCode = FindLoadBalanceGrp(grpId, &grp, cliGetCmc());
        if (errCode != BASE_OK)
        {
            netsnmp_set_request_error(reqInfo, request, SNMP_NOSUCHINSTANCE);
            break;
        }

        tableInfo = netsnmp_extract_table_info(request);

        switch (tableInfo->colnum)
        {
        case ColumnGsCableDocsLoadBalMacRangeGrpCfgId:
            grpId = *request->requestvb->val.integer;
            dbgstrm << "index=" << index << ", new grpId=" << grpId << endl;
            break;

        case ColumnGsCableDocsLoadBalMacRangeCfgIndex:
            macRangeIndex = *request->requestvb->val.integer;
            dbgstrm << macRangeIndex << endl;
            break;

        case ColumnGsCableDocsLoadBalMacRangeCfgStartMac:
            memcpy(grp.macRange[macRangeIndex - 1].start,
                   request->requestvb->val.string, 6);
            dbgstrm << grp << endl;
            errCode = SetFullLoadBalancingGrp(&grp, cliGetCmc());
            break;

        case ColumnGsCableDocsLoadBalMacRangeCfgEndMac:
            memcpy(grp.macRange[macRangeIndex - 1].end,
                   request->requestvb->val.string, 6);
            dbgstrm << grp << endl;
            errCode = SetFullLoadBalancingGrp(&grp, cliGetCmc());
            break;

        case ColumnGsCableDocsLoadBalMacRangeCfgOption:
            switch (*request->requestvb->val.integer)
            {
            case RowStatusDestroy:
                /* Note: this index is not content of table.  It is the "Instance" field
                 *       in MIB-Browser.
                 */
                MacAddressT start, end;
                memcpy(start.addr, grp.macRange[macRangeIndex-1].start, 6);
                memcpy(end.addr, grp.macRange[macRangeIndex-1].end, 6);
                errCode = RemoveCnuRangeFromLoadBalanceGrp(grpId,
                                                           &start, &end,
                                                           cliGetCmc());
                break;

            default:
                break;
            }
            break;

        default:
            break;
        }

        if (errCode != BASE_OK)
        {
            netsnmp_set_request_error(reqInfo, request, SNMP_ERR_BADVALUE);
            break;
        }
    }
    return SNMP_ERR_NOERROR;
}

int DocsLoadBalMacRangeCfgSetAction(netsnmp_mib_handler               *handler,
                                    netsnmp_handler_registration      *regInfo,
                                    netsnmp_agent_request_info        *reqInfo,
                                    netsnmp_request_info              *requests)
{
    dbgstrm << "Start." << endl;
    return SNMP_ERR_NOERROR;
}

int DocsLoadBalMacRangeCfgSetUndo(netsnmp_mib_handler               *handler,
                                  netsnmp_handler_registration      *regInfo,
                                  netsnmp_agent_request_info        *reqInfo,
                                  netsnmp_request_info              *requests)
{
    dbgstrm << "Start." << endl;
    return SNMP_ERR_NOERROR;
}

/** handles requests for the netSnmpIETFWGTable table */
int DocsLoadBalMacRangeCfgHandler(netsnmp_mib_handler               *handler,
                                  netsnmp_handler_registration      *regInfo,
                                  netsnmp_agent_request_info        *reqInfo,
                                  netsnmp_request_info              *requests)
{
    map<int, SnmpOperationHandler>::iterator iter;
    iter = snmpHandler.find(reqInfo->mode);
    assert(iter != snmpHandler.end());
    iter->second(handler, regInfo, reqInfo, requests);

    return SNMP_ERR_NOERROR;
}
