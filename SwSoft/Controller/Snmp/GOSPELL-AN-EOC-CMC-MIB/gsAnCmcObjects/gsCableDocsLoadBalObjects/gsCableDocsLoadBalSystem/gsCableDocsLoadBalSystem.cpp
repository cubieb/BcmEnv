/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */
#include "SystemInclude.h"
#include "BcmController.h"

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "Debug.h"
#include "LoadBalanceMgt.h"
#include "gsCableDocsLoadBalSystem.h"

static CMCOAM_GetLdBlcDynCfgRspT  LdBlcCfg;

/** Initializes the gsCableDocsLoadBalSystem module */
void InitGsCableDocsLoadBalSystem(void)
{
    const oid DocsLoadBalMethodoid[] = { 1,3,6,1,4,1,22764,1015,9026,2,4,1,1 };
    const oid DocsLoadBalPeriodoid[] = { 1,3,6,1,4,1,22764,1015,9026,2,4,1,2 };
    const oid DocsLoadBalNumPeriodsoid[] = { 1,3,6,1,4,1,22764,1015,9026,2,4,1,3 };
    const oid DocsLoadBalOverloadThresholdoid[] = { 1,3,6,1,4,1,22764,1015,9026,2,4,1,4 };
    const oid DocsLoadBalDifferenceThresholdoid[] = { 1,3,6,1,4,1,22764,1015,9026,2,4,1,5 };
    const oid DocsLoadBalMaxMovesPerPeriodoid[] = { 1,3,6,1,4,1,22764,1015,9026,2,4,1,6 };
    const oid DocsLoadBalMinHoldTimePerModemoid[] = { 1,3,6,1,4,1,22764,1015,9026,2,4,1,7 };
    const oid DocsLoadBalRangingOverrideModeoid[] = { 1,3,6,1,4,1,22764,1015,9026,2,4,1,8 };
    const oid DocsLoadBalDCCInitTechATDMAoid[] = { 1,3,6,1,4,1,22764,1015,9026,2,4,1,9 };
    const oid DocsLoadBalDCCInitTechSCDMAoid[] = { 1,3,6,1,4,1,22764,1015,9026,2,4,1,10 };
    const oid DocsLoadBalDBCInitTechATDMAoid[] = { 1,3,6,1,4,1,22764,1015,9026,2,4,1,11 };
    const oid DocsLoadBalDBCInitTechSCDMAoid[] = { 1,3,6,1,4,1,22764,1015,9026,2,4,1,12 };

    DEBUGMSGTL(("gsCableDocsLoadBalSystem", "Initializing\n"));

    //GetDynamicLoadBalanceConfig( &LdBlcCfg );
    
    netsnmp_register_scalar(
        netsnmp_create_handler_registration(
                                                    "gsCableDocsLoadBalMethod", 
                                                     HandlegsCableDocsLoadBalMethod,
                                                     DocsLoadBalMethodoid, 
                                                     OID_LENGTH(DocsLoadBalMethodoid),
                                                     HANDLER_CAN_RWRITE       ));
    
    netsnmp_register_scalar(
        netsnmp_create_handler_registration(
                                                    "gsCableDocsLoadBalPeriod", 
                                                    HandlegsCableDocsLoadBalPeriod,
                                                    DocsLoadBalPeriodoid, 
                                                    OID_LENGTH(DocsLoadBalPeriodoid),
                                                    HANDLER_CAN_RWRITE        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration(
                                                    "gsCableDocsLoadBalNumPeriods", 
                                                    HandlegsCableDocsLoadBalNumPeriods,
                                                    DocsLoadBalNumPeriodsoid, 
                                                    OID_LENGTH(DocsLoadBalNumPeriodsoid),
                                                    HANDLER_CAN_RWRITE        ));
    
    netsnmp_register_scalar(
        netsnmp_create_handler_registration(
                                                    "gsCableDocsLoadBalOverloadThreshold", 
                                                    HandlegsCableDocsLoadBalOverloadThreshold,
                                                    DocsLoadBalOverloadThresholdoid, 
                                                    OID_LENGTH(DocsLoadBalOverloadThresholdoid),
                                                    HANDLER_CAN_RWRITE        ));
    
    netsnmp_register_scalar(
        netsnmp_create_handler_registration(
                                                    "gsCableDocsLoadBalDifferenceThreshold", 
                                                    HandlegsCableDocsLoadBalDifferenceThreshold,
                                                    DocsLoadBalDifferenceThresholdoid, 
                                                    OID_LENGTH(DocsLoadBalDifferenceThresholdoid),
                                                    HANDLER_CAN_RWRITE        ));
    
    netsnmp_register_scalar(
        netsnmp_create_handler_registration(
                                                    "gsCableDocsLoadBalMaxMovesPerPeriod", 
                                                    HandlegsCableDocsLoadBalMaxMovesPerPeriod,
                                                    DocsLoadBalMaxMovesPerPeriodoid, 
                                                    OID_LENGTH(DocsLoadBalMaxMovesPerPeriodoid),
                                                    HANDLER_CAN_RWRITE        ));
    
    netsnmp_register_scalar(
        netsnmp_create_handler_registration(
                                                    "gsCableDocsLoadBalMinHoldTimePerModem", 
                                                    HandlegsCableDocsLoadBalMinHoldTimePerModem,
                                                    DocsLoadBalMinHoldTimePerModemoid, 
                                                    OID_LENGTH(DocsLoadBalMinHoldTimePerModemoid),
                                                    HANDLER_CAN_RWRITE        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration(
                                                    "gsCableDocsLoadBalRangingOverrideMode", 
                                                    HandlegsCableDocsLoadBalRangingOverrideMode,
                                                    DocsLoadBalRangingOverrideModeoid, 
                                                    OID_LENGTH(DocsLoadBalRangingOverrideModeoid),
                                                    HANDLER_CAN_RWRITE        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration(
                                                    "gsCableDocsLoadBalDCCInitTechATDMA", 
                                                    HandlegsCableDocsLoadBalDCCInitTechATDMA,
                                                    DocsLoadBalDCCInitTechATDMAoid, 
                                                    OID_LENGTH(DocsLoadBalDCCInitTechATDMAoid),
                                                    HANDLER_CAN_RWRITE        ));
    
    netsnmp_register_scalar(
        netsnmp_create_handler_registration(
                                                    "gsCableDocsLoadBalDCCInitTechSCDMA", 
                                                    HandlegsCableDocsLoadBalDCCInitTechSCDMA,
                                                    DocsLoadBalDCCInitTechSCDMAoid, 
                                                    OID_LENGTH(DocsLoadBalDCCInitTechSCDMAoid),
                                                    HANDLER_CAN_RWRITE        ));
    
    netsnmp_register_scalar(
        netsnmp_create_handler_registration(
                                                    "gsCableDocsLoadBalDBCInitTechATDMA", 
                                                    HandlegsCableDocsLoadBalDBCInitTechATDMA,
                                                    DocsLoadBalDBCInitTechATDMAoid, 
                                                    OID_LENGTH(DocsLoadBalDBCInitTechATDMAoid),
                                                    HANDLER_CAN_RWRITE        ));

    netsnmp_register_scalar(
        netsnmp_create_handler_registration(
                                                    "gsCableDocsLoadBalDBCInitTechSCDMA", 
                                                    HandlegsCableDocsLoadBalDBCInitTechSCDMA,
                                                    DocsLoadBalDBCInitTechSCDMAoid, 
                                                    OID_LENGTH(DocsLoadBalDBCInitTechSCDMAoid),
                                                    HANDLER_CAN_RWRITE        ));
    
}

int
HandlegsCableDocsLoadBalMethod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    U8 method;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) 
    {
        case MODE_GET:
            ret = GetDynamicLoadBalanceConfig( &LdBlcCfg );
            if (BASE_OK != ret)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_GENERR;
            }            
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &LdBlcCfg.method,
                                     sizeof( LdBlcCfg.method ));
        break;

        /*
         * SET REQUEST
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( SNMP_ERR_NOERROR != ret ) 
            {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
        break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if ( 0 /* XXX if malloc, or whatever, failed: */) 
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
        break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
        break;

        case MODE_SET_ACTION:            
            if ( 0 ) 
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE/* some error */);
            }
        break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            method = *requests->requestvb->val.integer ;
            ret = SetDynamicLoadBalanceMethod( &method );
            if (  BASE_OK != ret /* XXX: error? */) 
            {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_GENERR;
            }
        break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if ( 0 /* XXX: error? */) 
            {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
        break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gsCableDocsLoadBalMethod\n", 
                reqinfo->mode );
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}
int
HandlegsCableDocsLoadBalPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    U32 period;
    
    switch(reqinfo->mode) 
    {
        case MODE_GET:
            ret = GetDynamicLoadBalanceConfig( &LdBlcCfg );
            if (BASE_OK != ret)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_GENERR;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                            &LdBlcCfg.period , sizeof( LdBlcCfg.period )  );
        break;
        
        case MODE_SET_RESERVE1:
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) 
            {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
        break;

        case MODE_SET_RESERVE2:
            if ( 0 ) 
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
        break;

        case MODE_SET_FREE:
        break;

        case MODE_SET_ACTION:     
            if ( 0 ) 
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            }
        break;

        case MODE_SET_COMMIT:
        /*Time in seconds between load balancing checks. 
           Minimum time is 30 seconds. (0=no change)*/

            if ( 0 == *requests->requestvb->val.integer )
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_NOERROR);
                return SNMP_ERR_NOERROR;
            }            
            period = ( *requests->requestvb->val.integer <  30) ? 30 : *requests->requestvb->val.integer;  
            ret = SetDynamicLoadBalancePeriod( &period );
            if ( BASE_OK != ret ) 
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_COMMITFAILED;
            }
        break;

        case MODE_SET_UNDO:
            if ( 0 ) 
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
        break;

        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gsCableDocsLoadBalPeriod\n", 
                reqinfo->mode );
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
HandlegsCableDocsLoadBalNumPeriods(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    U32 NumPeriods;

    switch(reqinfo->mode) 
    {
        case MODE_GET:
            ret = GetDynamicLoadBalanceConfig( &LdBlcCfg );
            if (BASE_OK != ret)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_GENERR;
            }
            
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &LdBlcCfg.wa_period, sizeof(LdBlcCfg.wa_period));
        break;

        case MODE_SET_RESERVE1:
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) 
            {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
        break;

        case MODE_SET_RESERVE2:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
        break;

        case MODE_SET_FREE:
        break;

        case MODE_SET_ACTION:
            NumPeriods = *requests->requestvb->val.integer;
            if ( 0 == NumPeriods )
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_NOERROR);
                return SNMP_ERR_NOERROR;
            }     
            ret = SetDynamicLoadWeightedAveragePeriod( &NumPeriods );
            if ( BASE_ERROR_PARAM == ret ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
                return SNMP_ERR_BADVALUE;
            }
            else if ( BASE_OK != ret ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_GENERR;
            }
        break;

        case MODE_SET_COMMIT:            
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
        break;

        case MODE_SET_UNDO:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
        break;

        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gsCableDocsLoadBalNumPeriods\n", 
                reqinfo->mode );
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
HandlegsCableDocsLoadBalOverloadThreshold(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    U32 OverloadThreshold;   
    switch(reqinfo->mode) 
    {
        case MODE_GET:
            ret = GetDynamicLoadBalanceConfig( &LdBlcCfg );
            if (BASE_OK != ret)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_GENERR;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                    &LdBlcCfg.overload_threshold, sizeof(LdBlcCfg.overload_threshold));
        break;

        case MODE_SET_RESERVE1:
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
        break;

        case MODE_SET_RESERVE2:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
        break;

        case MODE_SET_FREE:
        break;

        case MODE_SET_ACTION:
            OverloadThreshold = *requests->requestvb->val.integer;
            if ( 0 == OverloadThreshold )
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_NOERROR);
                return SNMP_ERR_NOERROR;
            } 
            ret = SetDynamicLoadOverloadThreshold( &OverloadThreshold );
            if ( BASE_ERROR_PARAM == ret ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
                return SNMP_ERR_BADVALUE;                
            }
            else if ( BASE_OK != ret ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_GENERR;                
            }
        break;

        case MODE_SET_COMMIT:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
        break;

        case MODE_SET_UNDO:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
        break;

        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gsCableDocsLoadBalOverloadThreshold\n", 
                reqinfo->mode );
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
HandlegsCableDocsLoadBalDifferenceThreshold(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    U32 DiffThreshold;
    
    switch(reqinfo->mode) 
    {
        case MODE_GET:
            ret = GetDynamicLoadBalanceConfig( &LdBlcCfg );
            if (BASE_OK != ret)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_GENERR;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
                                     &LdBlcCfg.diff_threshold, sizeof( LdBlcCfg.diff_threshold ));
        break;

        case MODE_SET_RESERVE1:
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
                return SNMP_ERR_GENERR;
            }
        break;

        case MODE_SET_RESERVE2:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
        break;

        case MODE_SET_FREE:
        break;

        case MODE_SET_ACTION:
            DiffThreshold = *requests->requestvb->val.integer;
            if ( 0 == DiffThreshold )
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_NOERROR);
                return SNMP_ERR_NOERROR;
            }             
            ret = SetDynamicLoadDiffThreshold( &DiffThreshold );
            if ( BASE_ERROR_PARAM == ret ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
                return SNMP_ERR_BADVALUE;
            }
            else if ( BASE_OK != ret ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_COMMITFAILED;
            }
        break;

        case MODE_SET_COMMIT:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
        break;

        case MODE_SET_UNDO:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
        break;

        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gsCableDocsLoadBalDifferenceThreshold\n", 
                reqinfo->mode );
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
HandlegsCableDocsLoadBalMaxMovesPerPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    U32 MaxMovesPerPeriod;
    switch(reqinfo->mode) 
    {
        case MODE_GET:
            ret = GetDynamicLoadBalanceConfig( &LdBlcCfg );
            if (BASE_OK != ret)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_GENERR;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                  &LdBlcCfg.max_move, sizeof( LdBlcCfg.max_move ) );
        break;

        case MODE_SET_RESERVE1:
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
        break;

        case MODE_SET_RESERVE2:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
        break;

        case MODE_SET_FREE:
        break;

        case MODE_SET_ACTION:
            MaxMovesPerPeriod = *requests->requestvb->val.integer ;
            if ( 0 == MaxMovesPerPeriod ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
                return SNMP_ERR_NOERROR;
            }
            else if ( 0 > MaxMovesPerPeriod ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
                return SNMP_ERR_BADVALUE;  
            }
        break;

        case MODE_SET_COMMIT:
            ret = SetDynamicLoadMaxMove( &MaxMovesPerPeriod );
            if ( BASE_OK != ret ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_COMMITFAILED;
            }
        break;

        case MODE_SET_UNDO:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
        break;

        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gsCableDocsLoadBalMaxMovesPerPeriod\n", 
                reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
HandlegsCableDocsLoadBalMinHoldTimePerModem(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    U32 MinHoldTime;

    switch(reqinfo->mode) 
    {
        case MODE_GET:
            ret = GetDynamicLoadBalanceConfig( &LdBlcCfg );
            if (BASE_OK != ret)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_GENERR;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &LdBlcCfg.min_hold_time, sizeof(LdBlcCfg.min_hold_time) );
            break;

        case MODE_SET_RESERVE1:
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
        break;

        case MODE_SET_RESERVE2:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
        break;

        case MODE_SET_ACTION:
            MinHoldTime = *requests->requestvb->val.integer ;
            if ( 0 == MinHoldTime ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_NOERROR);
                return SNMP_ERR_NOERROR;
            }
            else if ( 0 >= MinHoldTime ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
                return SNMP_ERR_BADVALUE;               
            }
        break;

        case MODE_SET_COMMIT:
            ret = SetDynamicLoadMinHoldTime( &MinHoldTime );
            if ( BASE_OK != ret ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_COMMITFAILED;                
            }
        break;

        case MODE_SET_UNDO:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
        break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gsCableDocsLoadBalMinHoldTimePerModem\n", 
                reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
HandlegsCableDocsLoadBalRangingOverrideMode(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    U8 RangingOverrideMode;
    
    switch(reqinfo->mode) 
    {
        case MODE_GET:
            ret = GetDynamicLoadBalanceConfig( &LdBlcCfg );
            if (BASE_OK != ret)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_GENERR;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &LdBlcCfg.rang_override_mode, sizeof( LdBlcCfg.rang_override_mode ) );
        break;

        case MODE_SET_RESERVE1:
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
        break;

        case MODE_SET_RESERVE2:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
        break;

        case MODE_SET_FREE:
        break;

        case MODE_SET_ACTION:
            RangingOverrideMode = *requests->requestvb->val.integer;
            if ( 0 == RangingOverrideMode ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_NOERROR);
                return SNMP_ERR_NOERROR;
            }
            ret = SetDynamicLoadRangeOverrideMode( &RangingOverrideMode );
            if ( BASE_OK != ret ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_COMMITFAILED;
            }
        break;

        case MODE_SET_COMMIT:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
        break;

        case MODE_SET_UNDO:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
        break;

        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gsCableDocsLoadBalRangingOverrideMode\n", 
                reqinfo->mode );
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}
int
HandlegsCableDocsLoadBalDCCInitTechATDMA(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    U8 DCCInitTechATDMA;
    switch(reqinfo->mode) 
    {

        case MODE_GET:
            ret = GetDynamicLoadBalanceConfig( &LdBlcCfg );
            if (BASE_OK != ret)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_GENERR;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &LdBlcCfg.atdma_dcc_init_tech, sizeof( LdBlcCfg.atdma_dcc_init_tech ));
        break;

        case MODE_SET_RESERVE1:
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
        break;

        case MODE_SET_RESERVE2:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
        break;

        case MODE_SET_FREE:
        break;

        case MODE_SET_ACTION:
            DCCInitTechATDMA = *requests->requestvb->val.integer ;
            if ( DCCInitTechATDMA > 4 || DCCInitTechATDMA < 1 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
                return SNMP_ERR_BADVALUE;
            }
        break;

        case MODE_SET_COMMIT:
            ret = SetDynamicLoadAtdmaDccInitTechMode( &DCCInitTechATDMA );
            if ( BASE_OK != ret ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_COMMITFAILED;                
            }
        break;

        case MODE_SET_UNDO:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
        break;

        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gsCableDocsLoadBalDCCInitTechATDMA\n", 
                reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
HandlegsCableDocsLoadBalDCCInitTechSCDMA(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    U8 DCCInitTechSCDMA;
    
    switch(reqinfo->mode) 
    {
        case MODE_GET:
            ret = GetDynamicLoadBalanceConfig( &LdBlcCfg );
            if (BASE_OK != ret)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_GENERR;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     &LdBlcCfg.scdma_dcc_init_tech, sizeof( LdBlcCfg.scdma_dcc_init_tech ));
        break;

        case MODE_SET_RESERVE1:
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
        break;

        case MODE_SET_RESERVE2:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
        break;

        case MODE_SET_FREE:
        break;

        case MODE_SET_ACTION:
            DCCInitTechSCDMA = *requests->requestvb->val.integer ;
            if ( DCCInitTechSCDMA > 3 || DCCInitTechSCDMA < 1 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
                return SNMP_ERR_BADVALUE;
            }
        break;

        case MODE_SET_COMMIT:
            ret = SetDynamicLoadScdmaDccInitTechMode( &DCCInitTechSCDMA );
            if ( BASE_OK != ret ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_COMMITFAILED;
            }
        break;

        case MODE_SET_UNDO:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
        break;

        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gsCableDocsLoadBalDCCInitTechSCDMA\n", 
                reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
HandlegsCableDocsLoadBalDBCInitTechATDMA(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    U8 DBCInitTechATDMA;
    
    switch(reqinfo->mode) 
    {
        case MODE_GET:
            ret = GetDynamicLoadBalanceConfig( &LdBlcCfg );
            if (BASE_OK != ret)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_GENERR;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, 
                                     &LdBlcCfg.atdma_dbc_init_tech, sizeof( LdBlcCfg.atdma_dbc_init_tech ));
        break;

        case MODE_SET_RESERVE1:
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
        break;

        case MODE_SET_RESERVE2:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
        break;

        case MODE_SET_FREE:
        break;

        case MODE_SET_ACTION:
            DBCInitTechATDMA = *requests->requestvb->val.integer ;
            if ( DBCInitTechATDMA > 4 || DBCInitTechATDMA < 1 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
                return SNMP_ERR_BADVALUE;                
            }
        break;

        case MODE_SET_COMMIT:
            ret = SetDynamicLoadAtdmaDbcInitTechMode( &DBCInitTechATDMA );
            if ( BASE_OK != ret ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_BADVALUE;
            }
        break;

        case MODE_SET_UNDO:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
        break;

        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gsCableDocsLoadBalDBCInitTechATDMA\n", 
                reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
HandlegsCableDocsLoadBalDBCInitTechSCDMA(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    U8 DBCInitTechSCDMA;
    
    switch(reqinfo->mode) 
    {
        case MODE_GET:
            ret = GetDynamicLoadBalanceConfig( &LdBlcCfg );
            if (BASE_OK != ret)
            {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
                return SNMP_ERR_GENERR;
            }
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                      &LdBlcCfg.scdma_dbc_init_tech, sizeof( LdBlcCfg.scdma_dbc_init_tech ));
        break;

        case MODE_SET_RESERVE1:
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
        break;

        case MODE_SET_RESERVE2:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
        break;

        case MODE_SET_FREE:
        break;

        case MODE_SET_ACTION:
            DBCInitTechSCDMA = *requests->requestvb->val.integer ;
            if ( DBCInitTechSCDMA > 3 || DBCInitTechSCDMA < 1 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
                return SNMP_ERR_BADVALUE;                
            }
        break;

        case MODE_SET_COMMIT:
            ret = SetDynamicLoadScdmaDbcInitTechMode( &DBCInitTechSCDMA );
            if ( BASE_OK != ret ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                return SNMP_ERR_COMMITFAILED;                
            }
        break;

        case MODE_SET_UNDO:
            if ( 0 ) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
        break;

        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gsCableDocsLoadBalDBCInitTechSCDMA\n", 
                reqinfo->mode );
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
