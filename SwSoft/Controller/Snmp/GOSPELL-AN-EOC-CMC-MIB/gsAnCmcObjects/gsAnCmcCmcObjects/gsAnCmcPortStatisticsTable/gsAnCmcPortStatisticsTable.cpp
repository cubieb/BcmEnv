/*
 * Note: this file originally auto-generated by mib2c using
 *  $
 */
#include "SystemInclude.h"
#include "BcmController.h"

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "Debug.h"
#include "ChannelMgt.h"

#include "gsAnCmcPortStatisticsTable.h"
using namespace std;

#define GE 2
#define INNER 3
#define PON 4

uint32_t PortIndex[3];

/** Initializes the gsAnCmcPortStatisticsTable module */
void InitGsAnCmcPortStatisticsTable(void)
{
    const oid TableOid[] = {1,3,6,1,4,1,22764,1015,9026,2,2,6};
    const size_t TableOidLen = OID_LENGTH(TableOid);

    netsnmp_iterator_info *iinfo;
    netsnmp_handler_registration *reg;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("gsAnCmcPortStatisticsTable:init", "initializing AnCmcPortStatisticsTable\n"));

    reg = netsnmp_create_handler_registration(
              "gsAnCmcPortStatisticsTable", CmcPortStatisticsTableHandler, 
              TableOid, TableOidLen,
              HANDLER_CAN_RONLY
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: gsAnCmcPortStatisticsIndex */
                           0);
    table_info->min_column = ColPortIndexRxSpeed;//ColPortIndex 
    table_info->max_column = ColPortIndexTxSpeed;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = CmcPortStatisticsTableGetFirst;
    iinfo->get_next_data_point = CmcPortStatisticsTableGetNext;
    iinfo->table_reginfo = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
}


/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
CmcPortStatisticsTableGetFirst(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    dbgstrm << "Start." << endl;

    uint32_t *PortIndexP = PortIndex;
    for (int i = 2; PortIndexP < PortIndex + 3; ++PortIndexP, ++i)
    {
        dbgstrm << "index=" << *PortIndexP << endl;
        *PortIndexP = i;
    }

    *my_loop_context = PortIndex;
    return CmcPortStatisticsTableGetNext(my_loop_context, my_data_context, 
                                put_index_data,  mydata);
}

netsnmp_variable_list *
CmcPortStatisticsTableGetNext(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    dbgstrm << "Start." << endl;

    uint32_t *PortIndexP = (uint32_t *)*my_loop_context;
    if (NULL == PortIndexP)
    {
        dbgstrm << "No more PortStatistics." << endl;
        *my_loop_context = NULL;
        *my_data_context = NULL;
        return NULL;
    }
    
    if (PortIndexP < PortIndex + 3)
    {
        dbgstrm << "index=" << *PortIndexP << endl;
        snmp_set_var_value(put_index_data, PortIndexP, sizeof(uint32_t));
        *my_data_context = PortIndexP++;
        *my_loop_context = PortIndexP;
        return put_index_data;
    }

    *my_loop_context = NULL;
    *my_data_context = NULL;
    return NULL;
}

int CmcPortStatisticsTableGet(netsnmp_mib_handler               *handler,
                                                    netsnmp_handler_registration      *reginfo,
                                                    netsnmp_agent_request_info        *reqinfo,
                                                    netsnmp_request_info              *requests)
{
   
    netsnmp_request_info *request;
    netsnmp_table_request_info *tableInfo;
    
    dbgstrm << "Start." << endl; 

    uint32_t *entry;
    char *value = "100";

    /*
     * Read-support (also covers GetNext requests)
     */
    for (request = requests; request; request = request->next) 
    {
        entry = (uint32_t*)netsnmp_extract_iterator_context(request);      
        if ( NULL == entry )
        {
            dbgstrm << "entry is NULL" << endl;
            netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
            continue;
        }
        dbgstrm << "index=" << *entry << endl;
        
        tableInfo = netsnmp_extract_table_info(request);
        switch (tableInfo->colnum) 
        {
            case ColPortIndexRxSpeed:                
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                  value, strlen(value) ); 
            break;            
            
            case ColPortIndexTxSpeed:
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                  value, strlen(value) ); 
            break;            
            
            default:
                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
            break;
        }   
    }
    return SNMP_ERR_NOERROR;
}

typedef int(*CmcPortStatisticsHandlerP)(netsnmp_mib_handler           *handler,
                                      netsnmp_handler_registration  *reginfo,
                                      netsnmp_agent_request_info    *reqinfo,
                                      netsnmp_request_info          *requests);

struct CmcPortStatisticsHandlerDispath
{
    int mode;
    CmcPortStatisticsHandlerP handler;
};

/** handles requests for the gsAnCmcCdtTransSVidTable table */
int
CmcPortStatisticsTableHandler(
                        netsnmp_mib_handler               *handler,
                        netsnmp_handler_registration      *reginfo,
                        netsnmp_agent_request_info        *reqinfo,
                        netsnmp_request_info              *requests) 
{
    dbgstrm << "Start." << endl;
    DEBUGMSGTL(("CmcPortStatisticsTableHandler:", "Processing request (%d)\n", reqinfo->mode));  
    static struct CmcPortStatisticsHandlerDispath dispatch[1] =
    {
        /* Read-support (also covers GetNext requests) */
        {MODE_GET, CmcPortStatisticsTableGet}
        /* Write-support */
    };
    size_t i;
    for (i = 0; i < sizeof(dispatch) /sizeof(struct CmcPortStatisticsHandlerDispath); ++i)
    {
        if (reqinfo->mode == dispatch[i].mode)
        {
            int ret;
            ret = (*dispatch[i].handler)(handler, reginfo, reqinfo, requests);
            if (ret != SNMP_ERR_NOERROR)
            {
                printf("CmcPortStatisticsHandler> %d operation failed, ret = %d\n",
                       dispatch[i].mode, ret);
                return ret;
            }
            break;
        }
    }
    return SNMP_ERR_NOERROR;
}

