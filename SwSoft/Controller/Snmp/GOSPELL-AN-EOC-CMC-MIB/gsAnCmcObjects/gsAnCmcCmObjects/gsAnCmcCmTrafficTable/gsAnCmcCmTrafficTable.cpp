/*
 * Note: this file originally auto-generated by mib2c using
 *  $
 */

#include "SystemInclude.h"
#include "BcmController.h"

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "Debug.h"
#include "CnuStatusMgt.h"

#include "gsAnCmcCmTrafficTable.h"
using namespace std;

typedef struct CmTRafficTableIndexMacAddrStruct
{
    U8 CnuIndex;
    MacAddressT CnuMac;
}CmTrafficTableIndexMacT;
CmTrafficTableIndexMacT CmTrafficIndexMac[MaxCmNum];

static CMCOAM_CnuStatusT CnuStatus;
static CMCOAM_CnuStatusT *CurCMInfoEntryP, *NextCMInfoEntryP;

/** Initializes the gsAnCmcCmTrafficTable module */
/** Initialize the gsAnCmcCmTrafficTable table by defining its contents and how it's structured */
void InitGsAnCmcCmTrafficTable(void)
{
  /* here we initialize all the tables we're planning on supporting */
  
    const oid CmTrafficTableOid[] = {1,3,6,1,4,1,22764,1015,9026,2,1,4};
    const size_t CmTrafficTableOidLen = OID_LENGTH(CmTrafficTableOid);

    netsnmp_iterator_info *iinfo;
    netsnmp_handler_registration *reg;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("gsAnCmcCmTrafficTable:init", "initializing table gsAnCmcCmTrafficTable\n"));

    reg = netsnmp_create_handler_registration(
                  "gsAnCmcCmTrafficTable", CmTrafficTableHandler,
                  CmTrafficTableOid, CmTrafficTableOidLen,
                  HANDLER_CAN_RONLY
                  );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_OCTET_STR,  /* index: gsAnCmMacAddress */
                           ASN_INTEGER,  /* index: gsAnCmcCmIfIndex */
                           0);
    table_info->min_column = ColCmMac;
    table_info->max_column = ColCmIfOutErrors;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = CmTrafficTableGetFirst;
    iinfo->get_next_data_point = CmTrafficTableGetNext;
    iinfo->table_reginfo = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
CmTrafficTableGetFirst(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    BASE_ErrCode errCode;
    CurCMInfoEntryP = &CnuStatus;
    CmTrafficTableIndexMacT *CmTrafficTableIndexP = CmTrafficIndexMac;

    dbgstrm << "Start." << endl;

    memset(CmTrafficTableIndexP, 0, sizeof(CmTrafficTableIndexP));    
    errCode = GetFirstCMInfoMgt( CurCMInfoEntryP );
    if ( BASE_OK != errCode )
    {
        dbgstrm << "GetFirstCMInfo error." << endl;
        *my_loop_context = NULL;
        *my_data_context = NULL;
        return NULL;
    }

    snmp_set_var_value(put_index_data, CurCMInfoEntryP->cnu_mac, 
                sizeof(CurCMInfoEntryP->cnu_mac));
    snmp_set_var_value(put_index_data->next_variable, &CurCMInfoEntryP->cnu_index, 
                sizeof(U32));
    
    memcpy(CmTrafficTableIndexP->CnuMac.addr, 
                   CurCMInfoEntryP->cnu_mac, 
                   sizeof(CurCMInfoEntryP->cnu_mac));
    CmTrafficTableIndexP->CnuIndex = CurCMInfoEntryP->cnu_index;
    
    dbgstrm << "cnu_index=" << CurCMInfoEntryP->cnu_index <<" cnu_mac="<< '\t' << endl;

    *my_loop_context = (void *)CmTrafficTableIndexP;
    *my_data_context = (void *)CmTrafficTableIndexP;    
    return put_index_data; 
}

netsnmp_variable_list *
CmTrafficTableGetNext(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    BASE_ErrCode errCode;
    CmTrafficTableIndexMacT *CmTrafficTableIndexP = CmTrafficIndexMac;
    CmTrafficTableIndexMacT *GetCmTrafficTableIndexP = (CmTrafficTableIndexMacT *) (*my_loop_context);
        
    dbgstrm << "Start." << endl;
    
    while ( CmTrafficTableIndexP != CmTrafficIndexMac+MaxCmNum )
    {
        if ( NoneCm == CmTrafficTableIndexP->CnuIndex)
            return NULL;
        if ( !memcmp( GetCmTrafficTableIndexP->CnuMac.addr,
                                CmTrafficTableIndexP->CnuMac.addr, 
                                sizeof(CmTrafficTableIndexP->CnuMac.addr) )  )
        {
            break;
        }
        ++CmTrafficTableIndexP;
    }

    errCode = FindCMInfoMgt(CmTrafficTableIndexP->CnuMac, CurCMInfoEntryP);
    if ( BASE_OK != errCode )
    {
        *my_data_context = NULL;
        *my_loop_context = NULL;  
        return NULL;
    }

    NextCMInfoEntryP = &CnuStatus;
    errCode =  GetNextCMInfoMgt( CurCMInfoEntryP, NextCMInfoEntryP );
    if ( BASE_OK != errCode )
    {
        dbgstrm << "GetNextCMInfo error, no anymore CMs." << endl;
        *my_data_context = NULL; 
        *my_loop_context = NULL; 
        return NULL;
    }
    
    snmp_set_var_value(put_index_data, NextCMInfoEntryP->cnu_mac, 
                sizeof(NextCMInfoEntryP->cnu_mac));
    snmp_set_var_value(put_index_data->next_variable, &NextCMInfoEntryP->cnu_index, 
                sizeof(U32));

    ++CmTrafficTableIndexP;
    memcpy(CmTrafficTableIndexP->CnuMac.addr, 
                    NextCMInfoEntryP->cnu_mac, 
                    sizeof(NextCMInfoEntryP->cnu_mac));
    CmTrafficTableIndexP->CnuIndex = NextCMInfoEntryP->cnu_index;
    
    dbgstrm << "cnu_index=" << NextCMInfoEntryP->cnu_index <<" cnu_mac="<< '\t' << endl;

    *my_loop_context = (void *)CmTrafficTableIndexP;
    *my_data_context = (void *)CmTrafficTableIndexP;
    
    return put_index_data; 
}

typedef int(*CmTrafficHandlerP)( netsnmp_mib_handler           *handler,
                                                       netsnmp_handler_registration  *reginfo,
                                                       netsnmp_agent_request_info    *reqinfo,
                                                       netsnmp_request_info          *requests );

struct CmTrafficHandlerDispath
{
    int mode;
    CmTrafficHandlerP handler;
};

/** handles requests for the gsAnCmcCmTrafficTable table */
int
CmTrafficTableGet(
        netsnmp_mib_handler               *handler,
        netsnmp_handler_registration      *reginfo,
        netsnmp_agent_request_info        *reqinfo,
        netsnmp_request_info              *requests) 
{
    netsnmp_request_info *request;
    netsnmp_table_request_info *table_info;

    BASE_ErrCode errCode;
    //CMCOAM_CnuStatusT *CMInfoEntryP;     
    CmTrafficTableIndexMacT *ExtractCmTrafficIndexP;    

    dbgstrm << "Start." << endl;
    
    /*
     * Read-support (also covers GetNext requests)
     */
    for (request=requests; request; request=request->next) 
    {
        ExtractCmTrafficIndexP = (CmTrafficTableIndexMacT *)netsnmp_extract_iterator_context(request);

        if ( NULL == ExtractCmTrafficIndexP )
        {
            dbgstrm << "entry is NULL" << endl;
            netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
            continue;
        }
        
        dbgstrm << "index=" << ExtractCmTrafficIndexP->CnuIndex <<" CmMac=" << '\t' << endl;
        
        table_info = netsnmp_extract_table_info(request);
        switch (table_info->colnum) 
        {
            case ColCmMac:
                dbgstrm << " CmMac=" << '\t' <<" table->Column = " << ColCmMac << endl;

                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          ExtractCmTrafficIndexP->CnuMac.addr,
                                          sizeof(ExtractCmTrafficIndexP->CnuMac.addr) );
            break;
            
            case ColCmIfIndex:
                dbgstrm << " CmIfIndex=" << ExtractCmTrafficIndexP->CnuIndex <<" table->Column = " 
                            << ColCmIfIndex << endl;
                
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            ExtractCmTrafficIndexP->CnuIndex );
            break;
            
            case ColCmIfInOctets:
            {
                U32 InOctets = 0;

                errCode = BASE_OK;
                if ( BASE_OK != errCode )
                {
                    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    break;
                }
                
                dbgstrm << "for-SnmpSet: CmIfInOctets =  " << InOctets 
                            << " table->Column = " << ColCmIfInOctets << endl;  
                                
                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            InOctets );
            }
            break;
            
            case ColCmIfInUcastPkts:
            {
                U32 IfInUcastPkts = 0; 
                
                errCode = BASE_OK;
                if ( BASE_OK != errCode )
                {
                    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    continue;
                }
                
                dbgstrm << "for-SnmpSet: CmIfInUcastPkts =  " << IfInUcastPkts 
                            << " table->Column = " << ColCmIfInUcastPkts << endl;  
                
                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            IfInUcastPkts );
            }
            break;
            
            case ColCmIfInNUcastPkts:
            {
                U32 IfInNUcastPkts = 0; 
                
                errCode = BASE_OK;
                if ( BASE_OK != errCode )
                {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                
                dbgstrm << "for-SnmpSet: CmIfInNUcastPkts =  " << IfInNUcastPkts 
                            << " table->Column = " << ColCmIfInNUcastPkts << endl;  
                
                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                             IfInNUcastPkts );
            }
            break;

            case ColCmIfInDiscards:
            {
                U32 IfInDiscards = 0; 
                
                errCode = BASE_OK;
                if ( BASE_OK != errCode )
                {
                    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    continue;
                }
                
                dbgstrm << "for-SnmpSet: CmIfInDiscards =  " << IfInDiscards 
                            << " table->Column = " << ColCmIfInDiscards << endl;  
                
                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            IfInDiscards );
            }
            break;
            
            case ColCmIfInErrors:
            {
                U32 IfInErrors = 0; 
                
                errCode = BASE_OK;
                if ( BASE_OK != errCode )
                {
                    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    continue;
                }

                dbgstrm << "for-SnmpSet: CmIfInErrors =  " << IfInErrors 
                            << " table->Column = " << ColCmIfInErrors << endl;  
                
                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            IfInErrors);
            }
            break;
            
            case ColCmIfInUnknownProtos:
            {
                U32 IfInUnknownProtos = 0; 
                
                errCode = BASE_OK;
                if ( BASE_OK != errCode )
                {
                    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    continue;
                }

                dbgstrm << "for-SnmpSet: CmIfInUnknownProtos =  " << IfInUnknownProtos 
                            << " table->Column = " << ColCmIfInUnknownProtos << endl;  

                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            IfInUnknownProtos );
            }
            break;
            
            case ColCmIfOutOctets:
            {
                U32 IfOutOctets = 0; 
                
                errCode = BASE_OK;
                if ( BASE_OK != errCode )
                {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }

                dbgstrm << "for-SnmpSet: CmIfOutOctets =  " << IfOutOctets 
                            << " table->Column = " << ColCmIfOutOctets << endl;  
                
                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            IfOutOctets);
            }
            break;
            
            case ColCmIfOutUcastPkts:
            {
                U32 IfOutUcastPkts = 0; 
                
                errCode = BASE_OK;
                if ( BASE_OK != errCode )
                {
                    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    continue;
                }

                dbgstrm << "for-SnmpSet: CmIfOutUcastPkts =  " << IfOutUcastPkts 
                            << " table->Column = " << ColCmIfOutOctets << endl;  
                
                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            IfOutUcastPkts );
            }
            break;
            
            case ColCmIfOutNUcastPkts:
            {
                U32 IfOutNUcastPkts = 0; 
                
                errCode = BASE_OK;
                if ( BASE_OK != errCode )
                {
                    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    continue;
                }

                dbgstrm << "for-SnmpSet: CmIfOutNUcastPkts =  " << IfOutNUcastPkts 
                            << " table->Column = " << ColCmIfOutNUcastPkts << endl;    
                
                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            IfOutNUcastPkts );
            }
            break;
                
            case ColCmIfOutDiscards:
            {
                U32 IfOutDiscards = 0; 
                
                errCode = BASE_OK;
                if ( BASE_OK != errCode )
                {
                    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    continue;
                }

                dbgstrm << "for-SnmpSet: CmIfOutDiscards =  " << IfOutDiscards 
                            << " table->Column = " << ColCmIfOutDiscards << endl;    
                
                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            IfOutDiscards );
            }
            break;
                
            case ColCmIfOutErrors:
            {
               U32 IfOutErrors = 0; 
                
                errCode = BASE_OK;
                if ( BASE_OK != errCode )
                {
                    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    continue;
                }

                dbgstrm << "for-SnmpSet: CmIfOutErrors =  " << IfOutErrors 
                            << " table->Column = " << ColCmIfOutErrors << endl;    
                
                snmp_set_var_typed_integer( request->requestvb, ASN_COUNTER,
                                            IfOutErrors );
            }
            break;
            
            default:
                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
            break;
        }
    }
    return SNMP_ERR_NOERROR;
}

/** handles requests for the gsAnCmcCmTrafficTable table */
int
CmTrafficTableHandler(
            netsnmp_mib_handler               *handler,
            netsnmp_handler_registration      *reginfo,
            netsnmp_agent_request_info        *reqinfo,
            netsnmp_request_info              *requests) 
{
    DEBUGMSGTL(("gsAnCmcCmTrafficTable:handler", "Processing request (%d)\n", reqinfo->mode));
    dbgstrm << "Start." << endl;

    static struct CmTrafficHandlerDispath dispatch[1] =
    {
        /* Read-support (also covers GetNext requests) */
        {MODE_GET, CmTrafficTableGet}
        /* Write-support */
    };
    size_t i;
    for (i = 0; i < sizeof(dispatch) /sizeof(struct CmTrafficHandlerDispath); ++i)
    {
        if (reqinfo->mode == dispatch[i].mode)
        {
            int ret;
            ret = (*dispatch[i].handler)(handler, reginfo, reqinfo, requests);
            if (ret != SNMP_ERR_NOERROR)
            {
                printf("CmTrafficTableHandler> %d operation failed, ret = %d\n",
                       dispatch[i].mode, ret);
                return ret;
            }
            break;
        }
    }
    return SNMP_ERR_NOERROR;
}



