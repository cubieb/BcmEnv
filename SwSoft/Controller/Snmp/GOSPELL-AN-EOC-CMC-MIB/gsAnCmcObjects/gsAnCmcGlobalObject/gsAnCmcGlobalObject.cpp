/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 * Last modified: 2014-04-24
 */
#include "SystemInclude.h"
#include "BcmController.h"

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "Debug.h"
#include "CnuStatusMgt.h"
#include "CmcGlobalConfigMgt.h"

#include "gsAnCmcGlobalObject.h"

using namespace std;
CxxBeginNameSpace(Snmp)
CxxBeginNameSpace(GsAnCmcGlobalObject)

/** Initializes the gsAnCmcGlobalObject module */
void InitGsAnCmcGlobalObject(void)
{
    const oid upstreamErrorRateThresholdOid[] = { 1,3,6,1,4,1,22764,1015,9026,2,25,1 };
    const oid cmcCmMacAddressOid[] = { 1,3,6,1,4,1,22764,1015,9026,2,25,2 };
    const oid cmcUpstreamSnrThresholdOid[] = { 1,3,6,1,4,1,22764,1015,9026,2,25,3 };
    const oid cmcMaxCmThresholdOid[] = { 1,3,6,1,4,1,22764,1015,9026,2,25,4 };
    const oid cmcCmNumberOid[] = { 1,3,6,1,4,1,22764,1015,9026,2,25,5 };
    const oid cmcDdosAttackTypeOid[] = { 1,3,6,1,4,1,22764,1015,9026,2,25,6 };
    const oid cmcAllCmResetNowOid[] = { 1,3,6,1,4,1,22764,1015,9026,2,25,7 };
    const oid cmcAllCmDeleteNowOid[] = { 1,3,6,1,4,1,22764,1015,9026,2,25,8 };

    netsnmp_handler_registration* handler;

    handler = netsnmp_create_handler_registration(
        "gsAnExtCmcUpstreamErrorRateThreshold",
        HandleCmcUpstreamErrorRateThreshold,
        upstreamErrorRateThresholdOid,
        OID_LENGTH(upstreamErrorRateThresholdOid),
        HANDLER_CAN_RWRITE);
    netsnmp_register_scalar(handler);

    handler = netsnmp_create_handler_registration(
        "HandleCmcCmMacAddress",
        HandleCmcCmMacAddress,
        cmcCmMacAddressOid,
        OID_LENGTH(cmcCmMacAddressOid),
        HANDLER_CAN_RONLY);
    netsnmp_register_scalar(handler);


    handler = netsnmp_create_handler_registration(
        "HandleCmcUpstreamSnrThreshold",
        HandleCmcUpstreamSnrThreshold,
        cmcUpstreamSnrThresholdOid,
        OID_LENGTH(cmcUpstreamSnrThresholdOid),
        HANDLER_CAN_RWRITE);
    netsnmp_register_scalar(handler);

    handler = netsnmp_create_handler_registration(
        "gsAnExtCmcMaxCmThreshold",
        HandleCmcMaxCmThreshold,
        cmcMaxCmThresholdOid,
        OID_LENGTH(cmcMaxCmThresholdOid),
        HANDLER_CAN_RWRITE);
    netsnmp_register_scalar(handler);

    handler = netsnmp_create_handler_registration(
        "gsAnExtCmcCmNumber",
        HandleCmcCmNumber,
        cmcCmNumberOid,
        OID_LENGTH(cmcCmNumberOid),
        HANDLER_CAN_RONLY);
    netsnmp_register_scalar(handler);

    handler = netsnmp_create_handler_registration(
        "gsAnExtCmcDdosAttackType",
        HandleCmcDdosAttackType,
        cmcDdosAttackTypeOid,
        OID_LENGTH(cmcDdosAttackTypeOid),
        HANDLER_CAN_RONLY);
    netsnmp_register_scalar(handler);

    handler = netsnmp_create_handler_registration(
        "gsAnCmcAllCmResetNow",
        HandleCmcAllCmResetNow,
        cmcAllCmResetNowOid,
        OID_LENGTH(cmcAllCmResetNowOid),
        HANDLER_CAN_RWRITE);
    netsnmp_register_scalar(handler);

    handler = netsnmp_create_handler_registration(
        "gsAnCmcAllCmDeleteNow",
        HandleCmcAllCmDeleteNow,
        cmcAllCmDeleteNowOid,
        OID_LENGTH(cmcAllCmDeleteNowOid),
        HANDLER_CAN_RWRITE);
    netsnmp_register_scalar(handler);
}

int HandleCmcUpstreamErrorRateThreshold(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info   *reqinfo,
    netsnmp_request_info         *requests)
{
    int ret, threshold;

    switch(reqinfo->mode)
    {
    case MODE_GET:
        GetUpstreamErrorRateThreshold(&threshold);
        snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, threshold);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR)
        {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        threshold = *requests->requestvb->val.integer;
        if (!SetUpstreamErrorRateThreshold(threshold))
        {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
    case MODE_SET_UNDO:
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in %s\n",
            reqinfo->mode,  __FUNCTION__);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

/* Note:  don't know the meaning of this node, we implement this
 * function just to avoid compiling error.
 */
int HandleCmcCmMacAddress(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info   *reqinfo,
    netsnmp_request_info         *requests)
{   
    uint8_t mac[6] = {0, 0, 0, 0, 0, 0};
    switch(reqinfo->mode)
    {
    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb,
            ASN_OCTET_STR, mac, 6);
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in %s\n",
            reqinfo->mode,  __FUNCTION__);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int HandleCmcUpstreamSnrThreshold(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info   *reqinfo,
    netsnmp_request_info         *requests)
{
    int ret, threshold;
    
    switch(reqinfo->mode)
    {
    case MODE_GET:
        GetUpstreamSnrThreshold(&threshold);
        snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, threshold);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR)
        {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        threshold = *requests->requestvb->val.integer;
        if (!SetUpstreamSnrThreshold(threshold))
        {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
    case MODE_SET_UNDO:
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in %s\n",
            reqinfo->mode,  __FUNCTION__);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int HandleCmcMaxCmThreshold(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info   *reqinfo,
    netsnmp_request_info         *requests)
{
    int ret, threshold;
    
    switch(reqinfo->mode)
    {
    case MODE_GET:
        GetMaxCnuOnlieMgt(&threshold);
        snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, threshold);
        break;

    case MODE_SET_RESERVE1:
        /* or you could use netsnmp_check_vb_type_and_size instead */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR)
        {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        threshold = *requests->requestvb->val.integer;
        if (!SetMaxCnuOnlieMgt(threshold))
        {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
    case MODE_SET_UNDO:
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in %s\n",
            reqinfo->mode,  __FUNCTION__);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int HandleCmcCmNumber(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info   *reqinfo,
    netsnmp_request_info         *requests)
{    
    int number;
    switch(reqinfo->mode)
    {
    case MODE_GET:
        if (BASE_OK != GetCnuOnlieMgt(&number))
        {
            dbgstrm << "HandleCmcCmNumber error." << endl;
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
        }
        snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, number);
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in %s\n",
            reqinfo->mode,  __FUNCTION__);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int HandleCmcDdosAttackType(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info   *reqinfo,
    netsnmp_request_info         *requests)
{   
    int type;
    switch(reqinfo->mode)
    {
    case MODE_GET:
        GetDdosAttackType(&type);
        snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, type);
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in %s\n",
            reqinfo->mode,  __FUNCTION__);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int HandleCmcAllCmResetNow(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info   *reqinfo,
    netsnmp_request_info         *requests)
{
    int ret;

    switch(reqinfo->mode)
    {
    case MODE_GET:
        snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, 2);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_int_range(requests->requestvb, 1, 1);
        if (ret != SNMP_ERR_NOERROR)
        {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (!DeleteAllCm())
        {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
    case MODE_SET_UNDO:
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in %s\n",
            reqinfo->mode,  __FUNCTION__);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int HandleCmcAllCmDeleteNow(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *reginfo,
    netsnmp_agent_request_info   *reqinfo,
    netsnmp_request_info         *requests)
{
    int ret;

    switch(reqinfo->mode)
    {
    case MODE_GET:
        snmp_set_var_typed_integer(requests->requestvb, ASN_INTEGER, 2);
        break;

    case MODE_SET_RESERVE1:
        ret = netsnmp_check_vb_int_range(requests->requestvb, 1, 1);
        if (ret != SNMP_ERR_NOERROR)
        {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        if (!DeleteAllCm())
        {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
    case MODE_SET_UNDO:
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in %s\n",
            reqinfo->mode,  __FUNCTION__);
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

CxxEndNameSpace /* namespace GsAnCmcGlobalObject */
CxxEndNameSpace /* namespace Snmp */

