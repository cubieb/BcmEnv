/*
 * Note: this file originally auto-generated by mib2c using...
 *  $
 */

#include "SystemInclude.h"
#include "BcmController.h"

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "Debug.h"
#include "CnuServiceMgt.h"
#include "CnuStatusMgt.h"
#include "gsCableDocsServiceFlowCfgTable.h"
using namespace std;

static CMCOAM_CnuStatusT CnuStatus;
static CMCOAM_ServiceFlowT ServiceFlow;
static CMCOAM_CnuStatusT *CurCMInfoEntryP, *NexCMInfoEntryP;
static CMCOAM_ServiceFlowT *CurServiceFlowP, *NexServiceFlowP;
   
typedef struct CMIndexMacStruct
{
    U32 cnu_index;
    MacAddressT cnu_mac;
}CMIndexMacT, *pCMIndexMacT;

static CMIndexMacT CMIndexMac[MaxCMNum];

typedef int(*DocsServiceFlowCfgHandlerP)(netsnmp_mib_handler           *handler,
                                      netsnmp_handler_registration  *reginfo,
                                      netsnmp_agent_request_info    *reqinfo,
                                      netsnmp_request_info          *requests);

struct DocsServiceFlowCfgHandlerDispath
{
    int mode;
    DocsServiceFlowCfgHandlerP handler;
};

/** Initialize the gsCableDocsServiceFlowCfgTable table by defining its contents and how it's structured */
void InitGsCableDocsServiceFlowCfgTable(void)
{
    const oid Tableoid[] = {1,3,6,1,4,1,22764,1015,9026,2,5,1};
    const size_t TableoidLen = OID_LENGTH(Tableoid);
    
    netsnmp_iterator_info *iinfo;
    netsnmp_handler_registration *reg;
    netsnmp_table_registration_info *table_info;

    dbgstrm << "Start." << endl;

    DEBUGMSGTL(("gsCableDocsServiceFlowCfgTable:init", "initializing table gsCableDocsServiceFlowCfgTable\n"));
    
    reg = netsnmp_create_handler_registration( "gsCableDocsServiceFlowCfgTable",     
                                        DocsServiceFlowCfgHandler,
                                        Tableoid, TableoidLen,
                                        HANDLER_CAN_RONLY );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_UNSIGNED,  /* index: idIndex */
                           ASN_UNSIGNED,  /* index: gsCableDocsServiceFlowSfid */
                           0);

    /*
    ** min/max column will affect at the columns of MODE_GET . MODE_GET will not request 
    ** ColumnCMIndex and ColumnSFsfid  if min_column is setted by 3 .
    */
    table_info->min_column = ColumnCMIndex;
    table_info->max_column = ColumnSFPrimary;
    
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point = DocsServiceFlowCfgGetFirst;
    iinfo->get_next_data_point = DocsServiceFlowCfgGetNext;
    
    /*
    ** Table Iterator Helper is a child-helper of the table helper
    ** struct *table_info  includes min_column / min_column /netsnmp_variable_list *indexes /
    ** unsigned int  number_indexes (calculated automatically ) 
    */
    iinfo->table_reginfo = table_info;

    /*
    ** iterator operates (a series of steps) that call your code hooks from 
    ** your netsnmp_iterator_info registration pointer(iinfo).
    */
    netsnmp_register_table_iterator( reg, iinfo );

    /* Initialise the contents of the table here */

}

netsnmp_variable_list *
DocsServiceFlowCfgGetFirst(void **loopContext,
                          void **dataContext,
                          netsnmp_variable_list *putindexdata,
                          netsnmp_iterator_info *data)
{
    BASE_ErrCode errCode;
    uint32_t Index,CmIndex,CmSfIndex;
    pCMIndexMacT CMIndexMacP= CMIndexMac;

    dbgstrm << "Start." << endl;

    CurCMInfoEntryP = &CnuStatus;
    memset(CMIndexMacP,0,sizeof(CMIndexMacP));
    errCode = GetFirstCMInfoMgt( CurCMInfoEntryP );
    if ( BASE_OK != errCode )
    {
        dbgstrm << "GetFirstCMInfo error." << endl;
        *dataContext = NULL;
        *loopContext = NULL;
        return NULL;
    }

    CMIndexMacP->cnu_index = CurCMInfoEntryP->cnu_index;
    memcpy(CMIndexMacP->cnu_mac.addr , CurCMInfoEntryP->cnu_mac, 
                    sizeof(CurCMInfoEntryP->cnu_mac));

    CurServiceFlowP = &ServiceFlow;
    errCode = GetCMFirstServiceFlowMgt( CurCMInfoEntryP, CurServiceFlowP );
    if ( BASE_OK != errCode )
    {
        dbgstrm << "GetCMFirstServiceFlowMgt error." << endl;
        *dataContext = NULL;
        *loopContext = NULL;
        return NULL;
    } 

    CmSfIndex = CurServiceFlowP->sf_id;
    CmIndex = CurCMInfoEntryP->cnu_index << 22;
    
    snmp_set_var_value(putindexdata, &CurCMInfoEntryP->cnu_index, sizeof(U32));
    snmp_set_var_value(putindexdata->next_variable, &CurServiceFlowP->sf_id, sizeof(U32));

    /*
    ** mix the 2 indexes to one number for  passing  by dataContext and loopContext
    ** cmIndex is  high 10 bits of index , CmSfIndex is  low 22 bits of index
    */
    Index = CmIndex |CmSfIndex;
    
    dbgstrm << "index=" << Index <<" cmindex=" << CmIndex << " sfindex=" 
                    << CmSfIndex << endl;

    *dataContext = (void *)Index;
    *loopContext = (void *)Index;
    
    return putindexdata;     
}

netsnmp_variable_list *
DocsServiceFlowCfgGetNext(void **loopContext,
                          void **dataContext,
                          netsnmp_variable_list *putindexdata,
                          netsnmp_iterator_info *data)
{
    BASE_ErrCode errCode;
    uint32_t Index = (uint32_t) (*loopContext);
    uint32_t CmIndex = Index >> 22;
    uint32_t CmSfIndex = Index & 0x003fffff;
    
    MacAddressT FoundMac = {0};
    pCMIndexMacT CMIndexMacP = CMIndexMac;
    
    dbgstrm << "Start." << endl;

    while ( CMIndexMacP != CMIndexMac+MaxCMNum )
    {
        if ( 0 == CMIndexMacP->cnu_index )
            return NULL;
        if ( CmIndex == CMIndexMacP->cnu_index )
        {
            memcpy( &FoundMac, &CMIndexMacP->cnu_mac, sizeof(MacAddressT) );
            break;
        }
        ++CMIndexMacP;
    }
    
    errCode = FindCMInfoMgt( FoundMac, CurCMInfoEntryP);
    if ( BASE_OK != errCode )
    {
        *dataContext = NULL;
        *loopContext = NULL;
        return NULL;
    }    
    
    NexServiceFlowP = &ServiceFlow;
    errCode = GetCMNextServiceFlowMgt( CurCMInfoEntryP,CurServiceFlowP, NexServiceFlowP );
    if ( BASE_OK == errCode )
    {       
        CmIndex = CurCMInfoEntryP->cnu_index << 22 ;
        CmSfIndex = NexServiceFlowP->sf_id;
        Index = CmIndex |CmSfIndex;
        
        dbgstrm << "index=" << Index <<" cmindex=" << CmIndex 
                      << " sfindex=" << CmSfIndex << endl;

        snmp_set_var_value(putindexdata, &CurCMInfoEntryP->cnu_index, sizeof(U32));
        snmp_set_var_value(putindexdata->next_variable, &NexServiceFlowP->sf_id, sizeof(U32));
          
        *dataContext = (void *)Index;
        *loopContext = (void *)Index;

        //CurServiceFlowP = NexServiceFlowP; 
        return putindexdata;
    }

    NexCMInfoEntryP = &CnuStatus;
    errCode =  GetNextCMInfoMgt( CurCMInfoEntryP,NexCMInfoEntryP );
    if ( BASE_OK != errCode )
    {
        dbgstrm << "GetNextCMInfo error, no anymore CMs." << endl;
        *dataContext = NULL;
        *loopContext = NULL;        
        return NULL;
    }
    
    (++CMIndexMacP)->cnu_index = NexCMInfoEntryP->cnu_index;
    memcpy( CMIndexMacP->cnu_mac.addr, NexCMInfoEntryP->cnu_mac , 
                    sizeof(NexCMInfoEntryP->cnu_mac) );

    CurServiceFlowP = &ServiceFlow;
    errCode = GetCMFirstServiceFlowMgt( NexCMInfoEntryP, CurServiceFlowP );
    if ( BASE_OK != errCode )
    {
        dbgstrm << "GetCMFirstServiceFlowMgt error." << endl;
        *dataContext = NULL;
        *loopContext = NULL;
        return NULL;
    }
    CmIndex = NexCMInfoEntryP->cnu_index << 22 ;
    CmSfIndex = CurServiceFlowP->sf_id;
    Index = CmIndex |CmSfIndex;

    dbgstrm << "index=" << Index <<" cmindex=" << CmIndex 
                  << " sfindex=" << CmSfIndex << endl;

    snmp_set_var_value(putindexdata, &NexCMInfoEntryP->cnu_index, sizeof(U32));
    snmp_set_var_value(putindexdata->next_variable, &CurServiceFlowP->sf_id, sizeof(U32));

    *dataContext = (void *)Index;
    *loopContext = (void *)Index;
   
    return putindexdata;    
}

static pCMIndexMacT MatchCmSnmpIndex( pCMIndexMacT CMIndexMacP, uint32_t CmIndex)
{
    while ( CMIndexMacP != CMIndexMac+MaxCMNum )
    {
        if ( NoneCm== CMIndexMacP->cnu_index )
            return NULL;
        if ( CmIndex == CMIndexMacP->cnu_index )
            return CMIndexMacP;

        ++CMIndexMacP;
    }
    return NULL;
}

static BASE_ErrCode MatchSfSnmpIndex( pCMIndexMacT CMIndexMacP, uint32_t CmIndex, 
                                        uint32_t CmSfIndex, CMCOAM_ServiceFlowT *ServiceFlowP )
{
    BASE_ErrCode errCode;
    while ( CMIndexMacP != CMIndexMac+MaxCMNum )
    {        
        if ( NoneCm == CMIndexMacP->cnu_index)
        {
            errCode = BASE_ERROR;
            break;
        }
        if ( CmIndex == CMIndexMacP->cnu_index )
        {
            errCode = FindCMServiceFlowMgt(CMIndexMacP->cnu_mac, CmSfIndex, ServiceFlowP);
            break;
        }
        ++CMIndexMacP;
    }          
    return errCode;
}


int DocsServiceFlowGet(netsnmp_mib_handler               *handler,
                                                    netsnmp_handler_registration      *reginfo,
                                                    netsnmp_agent_request_info        *reqinfo,
                                                    netsnmp_request_info              *requests)
{
    netsnmp_request_info *request;
    netsnmp_table_request_info *tableInfo;

    BASE_ErrCode errCode;
    uint32_t Index,CmIndex,CmSfIndex;
    CMCOAM_ServiceFlowT *ServiceFlowP = &ServiceFlow;
    
    U32 i = 1;
    
    dbgstrm << "Start." << endl;
    
    /*
    ** agent will construct multiple internal netsnmp_request_info *requests structures and  
    ** pass them each to the appropriate registered MIB handler.
    ** requests is a list ,it include all request of table 
    */
    for (request=requests; request;  request=request->next, ++i)
    {
        Index = ( uint32_t )netsnmp_extract_iterator_context(request);
        CmIndex = Index >> 22;
        CmSfIndex = Index & 0x003fffff;

        dbgstrm << "index=" << Index <<" cmindex=" << CmIndex << " sfindex=" 
                      << CmSfIndex << endl;
      
        if ( NULL == (void *) Index )
        {
            dbgstrm << "entry is NULL" << endl;
            netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
            continue;
        }

        tableInfo = netsnmp_extract_table_info(request);
        switch (tableInfo->colnum)
        {
            case ColumnCMIndex:
                
                dbgstrm << "for-SnmpSet: cmIndex = " << CmIndex <<" table->Column = " 
                          << ColumnCMIndex << endl;
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                                     &CmIndex,
                                                     sizeof( CmIndex ) );
            
            break;

            case ColumnSFsfid:
            
                dbgstrm << "for-SnmpSet: CmSfIndex =  " << CmSfIndex << " table->Column = " 
                          << ColumnSFsfid << endl;  
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                                         &CmSfIndex,
                                                         sizeof( CmSfIndex ) );
            
            break;

            case ColumnSFsid:
            {         
                errCode = MatchSfSnmpIndex( CMIndexMac, CmIndex, CmSfIndex, ServiceFlowP );
                if ( BASE_OK != errCode )
                {
                    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    break;
                }
              
                dbgstrm << "for-SnmpSet: SFsid = " <<ServiceFlowP->s_id << " table->Column =  " 
                              << ColumnSFsid << endl;
                
                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                                         &ServiceFlowP->s_id,
                                                         sizeof( ServiceFlowP->s_id ) );
            }
            break;

            case ColumnSFCmMac:
            {           
                pCMIndexMacT CMIndexMacP;
                CMIndexMacP = MatchCmSnmpIndex( CMIndexMac, CmIndex );
                if ( BASE_OK == CMIndexMacP )
                {
                    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    break;
                }
                
                dbgstrm << "for-SnmpSet: CmMac = " << '\t' << " table->Column =  " 
                              << ColumnSFCmMac << endl;
                
                snmp_set_var_typed_value(request->requestvb, ASN_OCTET_STR,
                                                 CMIndexMacP->cnu_mac.addr,
                                                 sizeof(CMIndexMacP->cnu_mac.addr) );
            }
            break;

            case ColumnSFDirect:
            {
                errCode = MatchSfSnmpIndex( CMIndexMac, CmIndex, CmSfIndex, ServiceFlowP );
                if ( BASE_OK != errCode )
                {
                    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    break;
                }
                dbgstrm << "for-SnmpSet: SFDirect = " << ServiceFlowP->sf_direction 
                            << " table->Column =  " << ColumnSFDirect << endl;

                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                                 &ServiceFlowP->sf_direction, 
                                                 sizeof(ServiceFlowP->sf_direction) );
            }
            break;

            case ColumnSFPrimary:
            {
                errCode = MatchSfSnmpIndex( CMIndexMac, CmIndex, CmSfIndex, ServiceFlowP );
                if ( BASE_OK != errCode )
                {
                    netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
                    break;
                }
                
                dbgstrm << "for-SnmpSet: SFPrimary = " << ServiceFlowP->flow_type
                              << " table->Column =  " << ColumnSFPrimary << endl;

                snmp_set_var_typed_value(request->requestvb, ASN_INTEGER,
                                                 &ServiceFlowP->flow_type, 
                                                 sizeof(ServiceFlowP->flow_type) );
            }
            break;            

            default:
                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT);
            break;
        }          
        dbgstrm << "End Request loop i = " << i << '\n' << endl;
    }
    return SNMP_ERR_NOERROR;
}

int DocsServiceFlowSetReserve1(netsnmp_mib_handler      *handler,
                                                                         netsnmp_handler_registration      *reginfo,
                                                                         netsnmp_agent_request_info        *reqinfo,
                                                                         netsnmp_request_info              *requests)
{
    uint32_t* curIndex;
    netsnmp_request_info *request;
    netsnmp_table_request_info *tableInfo;

    dbgstrm << "Start." << endl;
    
    for (request=requests; request; request=request->next)
    {
        curIndex = (uint32_t *)netsnmp_extract_iterator_context(request);
        
        tableInfo = netsnmp_extract_table_info(request);
        switch (tableInfo->colnum)
        {
            case ColumnCMIndex:
            break;
            
            case ColumnSFsfid:
            break;
            
            case ColumnSFsid:
            break;
            
            case ColumnSFCmMac:
            break;
            
            case ColumnSFDirect:
                /* or possibly 'netsnmp_check_vb_type_and_size' */
            break;
                
            case ColumnSFPrimary:
                /* or possibly 'netsnmp_check_vb_type_and_size' */
            break;
                
            default:
                netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
            return SNMP_ERR_NOERROR;
        }
    }
    return SNMP_ERR_NOERROR;
}

int DocsServiceFlowSetReserve2(netsnmp_mib_handler      *handler,
                                                                         netsnmp_handler_registration      *reginfo,
                                                                         netsnmp_agent_request_info        *reqinfo,
                                                                         netsnmp_request_info              *requests)
{
    dbgstrm << "Start." << endl;
    netsnmp_request_info *request;    

    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
    return SNMP_ERR_NOERROR;
}

int DocsServiceFlowSetFree(netsnmp_mib_handler               *handler,
                             netsnmp_handler_registration      *reginfo,
                             netsnmp_agent_request_info        *reqinfo,
                             netsnmp_request_info              *requests)
{
    dbgstrm << "Start." << endl;
    return SNMP_ERR_NOERROR;
}

int DocsServiceFlowSetCommit(netsnmp_mib_handler               *handler,
                             netsnmp_handler_registration      *reginfo,
                             netsnmp_agent_request_info        *reqinfo,
                             netsnmp_request_info              *requests)
{
    dbgstrm << "Start." << endl;
    netsnmp_request_info *request;
    
    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
    return SNMP_ERR_NOERROR;
}
int DocsServiceFlowSetUndo(netsnmp_mib_handler               *handler,
                            netsnmp_handler_registration      *reginfo,
                            netsnmp_agent_request_info        *reqinfo,
                            netsnmp_request_info              *requests)
{
    dbgstrm << "Start." << endl;
    netsnmp_request_info *request;

    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
    return SNMP_ERR_NOERROR;
}
int DocsServiceFlowSetAction(netsnmp_mib_handler               *handler,
                             netsnmp_handler_registration      *reginfo,
                             netsnmp_agent_request_info        *reqinfo,
                             netsnmp_request_info              *requests)
{
    dbgstrm << "Start." << endl;
    netsnmp_request_info *request;

    netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE);
    return SNMP_ERR_NOERROR;
}


/** handles requests for the gsCableDocsServiceFlowCfgTable table */
int
DocsServiceFlowCfgHandler(    netsnmp_mib_handler               *handler,
                    netsnmp_handler_registration      *reginfo,
                    netsnmp_agent_request_info        *reqinfo,
                    netsnmp_request_info              *requests) 
{
    dbgstrm << "Start." << endl;
    DEBUGMSGTL(("DocsServiceFlowCfgHandler:handler", "Processing request (%d)\n", reqinfo->mode));  
    static struct DocsServiceFlowCfgHandlerDispath dispatch[7] =
    {
        /* Read-support (also covers GetNext requests) */
        {MODE_GET, DocsServiceFlowGet},
        /* Write-support */
        {MODE_SET_RESERVE1, DocsServiceFlowSetReserve1},
        {MODE_SET_RESERVE2, DocsServiceFlowSetReserve2},
        {MODE_SET_FREE, DocsServiceFlowSetFree},
        {MODE_SET_ACTION, DocsServiceFlowSetAction},
        {MODE_SET_UNDO, DocsServiceFlowSetUndo},
        {MODE_SET_COMMIT, DocsServiceFlowSetCommit},
    };
    
    size_t i;
    for (i = 0; i < sizeof(dispatch) /sizeof(struct DocsServiceFlowCfgHandlerDispath); ++i)
    {
        if (reqinfo->mode == dispatch[i].mode)
        {
            int ret;
            ret = (*dispatch[i].handler)(handler, reginfo, reqinfo, requests);
            if (ret != SNMP_ERR_NOERROR)
            {
                printf("DocsServiceFlowCfgHandler> %d operation failed, ret = %d\n",
                       dispatch[i].mode, ret);
                return ret;
            }
            break;
        }
    }
    return SNMP_ERR_NOERROR;
}


