/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 17695 2009-07-21 12:22:18Z dts12 $
 */
#include "SystemInclude.h"
#include "BcmController.h"

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <net-snmp/library/asn1.h>

#include "SnmpTypes.h"
#include "Util.h"
#include "Debug.h"
#include "CnuStatusMgt.h"
#include "gsCableDocsDsQosCfgTable.h"

using namespace std;

CxxBeginNameSpace(Snmp)
CxxBeginNameSpace(GsCableDocsDsQosCfgTable)

#define MaxDsQosCfgNumber 256
struct DsQosCfgIndex
{
    uint8_t mac[6];
};

inline ostream& operator << (ostream& os, DsQosCfgIndex const& index)
{
    os << "Mac = " <<  MacToString(index.mac);
    return os;
}

DsQosCfgIndex indexList[MaxDsQosCfgNumber];
size_t indexNumber;

int Get(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
int SetReserve1(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
int SetReserve2(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
int SetFree(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
int SetAction(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
int SetUndo(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
int SetCommit(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);

static pair<int, SnmpOperationHandler> handlerPairs[] =
{
    make_pair(MODE_GET, Get),
    make_pair(MODE_SET_RESERVE1, SetReserve1),
    make_pair(MODE_SET_RESERVE2, SetReserve2),
    make_pair(MODE_SET_FREE, SetFree),
    make_pair(MODE_SET_ACTION, SetAction),
    make_pair(MODE_SET_UNDO, SetUndo),
    make_pair(MODE_SET_COMMIT, SetCommit)
};
static map<int, SnmpOperationHandler> snmpHandler(handlerPairs, handlerPairs + 7);

void GetMac(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, DS_QoS_InfoT& entry);
void GetBrandwidth(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, DS_QoS_InfoT& entry);
void GetOperation(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, DS_QoS_InfoT& entry);

typedef void (*SnmpGetHandler)(netsnmp_agent_request_info&,
    netsnmp_request_info&, DS_QoS_InfoT&);

static pair<int, SnmpGetHandler> getHandlerPairs[] =
{
    make_pair(ColumnMac, GetMac),
    make_pair(ColumnWidth, GetBrandwidth),
    make_pair(ColumnOption, GetOperation)
};
static map<int, SnmpGetHandler> snmpGetValueHandler(getHandlerPairs, getHandlerPairs+3);

/* Initialize the gsCableDocsDsQosCfgTable table by defining its
 * contents and how it's structured
 */
void InitTable(void)
{
    const oid theOid[] = {1, 3, 6, 1, 4, 1, 22764, 1015, 9026, 2, 5, 32};
    const size_t oidLen = OID_LENGTH(theOid);

    netsnmp_handler_registration *reg;
    reg = netsnmp_create_handler_registration("gsCableDocsDsQosCfgTable",
        SnmpNodeHandler, &theOid[0], oidLen, HANDLER_CAN_RWRITE);

    netsnmp_table_registration_info *tableInfo;
    tableInfo = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(tableInfo, ASN_OCTET_STR, 0);
    tableInfo->min_column = ColumnMac;
    tableInfo->max_column = ColumnOption;

    netsnmp_iterator_info *iinfo;
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point = GetFirst;
    iinfo->get_next_data_point = GetNext;
    iinfo->table_reginfo = tableInfo;

    netsnmp_register_table_iterator(reg, iinfo);
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *GetFirst(void **loopContext,
    void **dataContext,
    netsnmp_variable_list *indexData,
    netsnmp_iterator_info *data)
{
    BASE_ErrCode errCode;
    dbgstrm << "Start." << endl;

    DS_QoS_InfoT qos;
    memset(&qos, 0, sizeof(DS_QoS_InfoT));
    errCode = GetFirstDsQosMgt(&qos);
    if (BASE_OK != errCode)
    {
        dbgstrm << "GetFirstDsQosMgt() failed." << endl;
        indexNumber = 0;
        *loopContext = NULL;
        *dataContext = NULL;
        return NULL;
    }
    indexNumber = 1;

    DsQosCfgIndex* index = indexList;
    CopyMacAddr(index->mac, qos.ds_qos_cnu_mac.addr);
    snmp_set_var_value(indexData, index->mac, 6);

    *loopContext = (void *) index;
    *dataContext = (void *) index;
    return indexData;
}

netsnmp_variable_list *GetNext(void **loopContext,
    void **dataContext,
    netsnmp_variable_list *indexData,
    netsnmp_iterator_info *data)
{
    BASE_ErrCode errCode;
    DsQosCfgIndex* index = (DsQosCfgIndex*) *loopContext;

    dbgstrm << "Start." << endl;
    if (index + 1 == indexList + MaxDsQosCfgNumber)
    {
        dbgstrm << "Exceeded max entry number." << endl;
        *loopContext = NULL;
        *dataContext = NULL;
        return NULL;
    }

    DS_QoS_InfoT qos;
    CopyMacAddr(qos.ds_qos_cnu_mac.addr, index->mac);

    errCode = GetNextDsQosMgt(&qos, &qos);
    if (BASE_OK != errCode)
    {
        dbgstrm << "GetNextDsQosMgt() failed." << endl;
        *loopContext = NULL;
        *dataContext = NULL;
        return NULL;
    }
    ++index;
    ++indexNumber;
    CopyMacAddr(index->mac, qos.ds_qos_cnu_mac.addr);
    snmp_set_var_value(indexData, index->mac, 6);

    dbgstrm << "index information: " << *index << endl;
    *loopContext = (void *) index;
    *dataContext = (void *) index;

    return indexData;
}

void GetMac(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, DS_QoS_InfoT& entry)
{
    snmp_set_var_typed_value(request.requestvb, ASN_OCTET_STR,
        entry.ds_qos_cnu_mac.addr, 6);
}

void GetBrandwidth(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, DS_QoS_InfoT& entry)
{
    snmp_set_var_typed_integer(request.requestvb, ASN_INTEGER,
            entry.bandwidth);
}

void GetOperation(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, DS_QoS_InfoT& entry)
{
    snmp_set_var_typed_integer(request.requestvb, ASN_INTEGER, 0);
}

int Get(netsnmp_mib_handler& handler, netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo, netsnmp_request_info& requests)
{
    netsnmp_request_info *request;
    netsnmp_table_request_info *tableInfo;
    DsQosCfgIndex* index;
    BASE_ErrCode errCode;

    dbgstrm << "Start." << endl;
    for (request = &requests; request != NULL; request = request->next)
    {
        index = (DsQosCfgIndex*) netsnmp_extract_iterator_context(request);
        if (index == NULL)
        {
            dbgstrm << "index is NULL" << endl;
            netsnmp_set_request_error(&reqInfo, request, SNMP_NOSUCHINSTANCE);
            continue;
        }
        dbgstrm << "index information: " << *index << endl;

        DS_QoS_InfoT qos;
        MacAddressT mac;
        CopyMacAddr(mac.addr, index->mac);
        errCode = SearchCnuMacToBandnwidthMapMgt(mac, &qos);
        if (BASE_OK != errCode)
        {
            netsnmp_set_request_error(&reqInfo, request, SNMP_NOSUCHINSTANCE);
            continue;
        }

        tableInfo = netsnmp_extract_table_info(request);

        map<int, SnmpGetHandler>::iterator iter;
        iter = snmpGetValueHandler.find(tableInfo->colnum);
        if (iter != snmpGetValueHandler.end())
        {
            iter->second(reqInfo, *request, qos);
        }
        else
        {
            dbgstrm << "Error, wrong table column number";
            netsnmp_set_request_error(&reqInfo, request, SNMP_NOSUCHOBJECT);
        }
    }

    return SNMP_ERR_NOERROR;
}

int SetReserve1(netsnmp_mib_handler& handler, netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo, netsnmp_request_info& requests)
{
    return SNMP_ERR_NOERROR;
}

int SetReserve2(netsnmp_mib_handler& handler, netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo, netsnmp_request_info& requests)
{
    netsnmp_request_info *request;
    netsnmp_table_request_info *tableInfo;
    static MacAddressT mac = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
    BASE_ErrCode errCode;

    DsQosCfgIndex* index;

    dbgstrm << "Start." << endl;

    for (request = &requests; request; request = request->next)
    {
        DS_QoS_InfoT qos;
        tableInfo = netsnmp_extract_table_info(request);
        switch (tableInfo->colnum)
        {
        case ColumnMac:
            CopyMacAddr(mac.addr, (uint8_t*)request->requestvb->val.string);
            dbgstrm << MacToString(mac.addr) << endl;
            break;

        case ColumnOption:
            /*
             * Create an (empty) new row structure
             */
            switch (*request->requestvb->val.integer)
            {
            case RowStatusCreate:
                if (indexNumber == MaxDsQosCfgNumber)
                {
                    errstrm << "Entry existed before, index = " << index << endl;
                    netsnmp_set_request_error(&reqInfo, request, SNMP_ERR_NOCREATION);
                    return SNMP_ERR_NOERROR;
                }
                index = &indexList[indexNumber++];
                CopyMacAddr(index->mac, mac.addr);
                CopyMacAddr(qos.ds_qos_cnu_mac.addr, mac.addr);
                if (SearchCnuMacToBandnwidthMapMgt(qos.ds_qos_cnu_mac, &qos) == BASE_OK)
                {
                    errstrm << "Entry existed before, index = " << index << endl;
                    netsnmp_set_request_error(&reqInfo, request, SNMP_ERR_NOCREATION);
                    return SNMP_ERR_NOERROR;
                }
                else
                {
                    qos.bandwidth = 0;
                    errCode = AddMacToBandnwidthMapMgt(&qos);
                    if (errCode != BASE_OK)
                    {
                        errstrm << "Can't create new entry, index = " << index << endl;
                        netsnmp_set_request_error(&reqInfo, request, SNMP_ERR_BADVALUE);
                        return SNMP_ERR_NOERROR;
                    }
                }
                netsnmp_insert_iterator_context(request, (void *)index);
                break;

            default:
                break;
            }
            break;

        default:
            break;
        }
    }
    return SNMP_ERR_NOERROR;
}

int SetFree(netsnmp_mib_handler& handler, netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo, netsnmp_request_info& requests)
{
    return SNMP_ERR_NOERROR;
}

int SetAction(netsnmp_mib_handler& handler, netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo, netsnmp_request_info& requests)
{
    netsnmp_request_info *request;
    netsnmp_table_request_info *tableInfo;

    BASE_ErrCode errCode;
    DsQosCfgIndex* index;

    dbgstrm << "Start." << endl;

    for (request = &requests; request; request = request->next)
    {
        index = (DsQosCfgIndex*) netsnmp_extract_iterator_context(request);
        if (index == NULL)
        {
            dbgstrm << "index is NULL" << endl;
            netsnmp_set_request_error(&reqInfo, request, SNMP_NOSUCHINSTANCE);
            break;
        }
        dbgstrm << "index information: " << *index << endl;

        DS_QoS_InfoT qos;
        CopyMacAddr(qos.ds_qos_cnu_mac.addr, index->mac);
        tableInfo = netsnmp_extract_table_info(request);
        switch (tableInfo->colnum)
        {
        case ColumnMac:
            /* do not let user to modify the mac field. to modify
             * this field, delete entry then add a new entry.
             */
            break;

        case ColumnWidth:
            qos.bandwidth = *request->requestvb->val.integer;
            errCode = AddMacToBandnwidthMapMgt(&qos);
            if (errCode != BASE_OK)
            {
                cerr << "Can't create new entry, index = " << index << endl;
                netsnmp_set_request_error(&reqInfo, request, SNMP_ERR_BADVALUE);
                return SNMP_ERR_NOERROR;
            }
            break;

        case ColumnOption:
            switch (*request->requestvb->val.integer)
            {
            case RowStatusDestroy:
                DeleteMacToBandnwidthMapMgt(qos.ds_qos_cnu_mac);
                break;

            default:
                break;
            }
            break;

        default:
            netsnmp_set_request_error(&reqInfo, request, SNMP_ERR_NOTWRITABLE);
            return SNMP_ERR_NOERROR;
        }
    }
    return SNMP_ERR_NOERROR;
}

int SetUndo(netsnmp_mib_handler& handler, netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo, netsnmp_request_info& requests)
{
    return SNMP_ERR_NOERROR;
}

int SetCommit(netsnmp_mib_handler& handler, netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo, netsnmp_request_info& requests)
{
    return SNMP_ERR_NOERROR;
}

/** handles requests for the gsCableDocsServiceFlowCfgTable table */
int SnmpNodeHandler(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *regInfo,
    netsnmp_agent_request_info *reqInfo,
    netsnmp_request_info *requests)
{
    map<int, SnmpOperationHandler>::iterator iter;
    iter = snmpHandler.find(reqInfo->mode);
    assert(iter != snmpHandler.end());
    iter->second(*handler, *regInfo, *reqInfo, *requests);

    return SNMP_ERR_NOERROR;
}

CxxEndNameSpace /* Snmp */
CxxEndNameSpace /* GsCableDocsDsQosCfgTable */
