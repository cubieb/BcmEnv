/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 17695 2009-07-21 12:22:18Z dts12 $
 */
#include "SystemInclude.h"

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "Util.h"
#include "Debug.h"
#include "SnmpTypes.h"
#include "SnmpCfgMgt.h"
#include "gsDslTrapHostTable.h"

using namespace std;

CxxBeginNameSpace(Snmp)
CxxBeginNameSpace(GsDslTrapHostTable)

static int Get(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
static int SetReserve1(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
static int SetReserve2(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
static int SetFree(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
static int SetAction(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
static int SetUndo(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
static int SetCommit(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);

static pair<int, SnmpOperationHandler> handlerPairs[] =
{
    make_pair(MODE_GET, Get),
    make_pair(MODE_SET_RESERVE1, SetReserve1),
    make_pair(MODE_SET_RESERVE2, SetReserve2),
    make_pair(MODE_SET_FREE, SetFree),
    make_pair(MODE_SET_ACTION, SetAction),
    make_pair(MODE_SET_UNDO, SetUndo),
    make_pair(MODE_SET_COMMIT, SetCommit)
};
static map<int, SnmpOperationHandler> snmpHandler(handlerPairs, handlerPairs + 7);

/* Get Handler */
static void GetHostIpAddr(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* data);
static void GetHostSnmpVer(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* data);
static void GetHostCommunity(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* data);
static void GetHostIsGosNmsServer(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* data);
static void GetHostRowStatus(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* data);
static void GetTrapHostEventType(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* data);
static void GetTrapHostMinEventLevel(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* data);

static pair<int, SnmpGetHandler> getHandlerPairs[] =
{
    make_pair(ColGsDslTrapHostIpAddr, GetHostIpAddr),
    make_pair(ColGsDslTrapHostSnmpVer, GetHostSnmpVer),
    make_pair(ColGsDslTrapHostCommunity, GetHostCommunity),
    make_pair(ColGsDslTrapHostIsGosNmsServer, GetHostIsGosNmsServer),
    make_pair(ColGsDslTrapHostRowStatus, GetHostRowStatus),
    make_pair(ColGsDslTrapHostEventType, GetTrapHostEventType),
    make_pair(ColGsDslTrapHostMinEventLevel, GetTrapHostMinEventLevel)
};
static map<int, SnmpGetHandler> snmpGetValueHandler(getHandlerPairs, getHandlerPairs+7);

static void SetReserve2TrapHostIpAddr(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* index);
static void SetReserve2TrapHostRowStatus(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* index);

static pair<int, SnmpSetReserve2Handler> setReserve2HandlerPairs[] =
{
    make_pair(ColGsDslTrapHostIpAddr, SetReserve2TrapHostIpAddr),
    make_pair(ColGsDslTrapHostRowStatus, SetReserve2TrapHostRowStatus),
};
static map<int, SnmpGetHandler> snmpSetReserve2Handler(setReserve2HandlerPairs, setReserve2HandlerPairs+2);

/** Initialize the gsDslTrapHostTable table by defining its contents and how it's structured */
void InitGsDslTrapHostTable(void)
{
    const oid tableOid[] = {1,3,6,1,4,1,22764,7900,3,1,4,33};
    const size_t oidLen  = OID_LENGTH(tableOid);
    netsnmp_handler_registration    *reg;

    reg = netsnmp_create_handler_registration("gsDslTrapHostTable",
        SnmpTableHandler, tableOid, oidLen,
        HANDLER_CAN_RWRITE);

    netsnmp_table_registration_info *tableInfo;
    tableInfo = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(tableInfo, ASN_IPADDRESS, 0);
    tableInfo->min_column = ColGsDslTrapHostIpAddr;
    tableInfo->max_column = ColGsDslTrapHostMinEventLevel;
    
    netsnmp_iterator_info *iinfo;
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point = GetFirst;
    iinfo->get_next_data_point  = GetNext;
    iinfo->table_reginfo        = tableInfo;
    
    netsnmp_register_table_iterator(reg, iinfo);
}

netsnmp_variable_list *GetFirst(void **loopContext,
    void **dataContext,
    netsnmp_variable_list *indexData,
    netsnmp_iterator_info *data)
{
    TrapCfgEntry entry;

    dbgstrm << "Start." << endl;
    if (GetFirstTrapHost(&entry))
    {
        /* link indexData with dataContext. when Get() operation, we extract
         * dataContext by indexData by netsnmp_extract_iterator_context().
         */
        dbgstrm << "hostIp = " << InetToString(entry.trapHostIpAddr) << endl;
        assert(entry.trapHostIpAddr != 0);
        snmp_set_var_typed_integer(indexData, ASN_IPADDRESS, entry.trapHostIpAddr);
        *dataContext = (void *)entry.trapHostIpAddr;
        *loopContext = (void *)entry.trapHostIpAddr;
        return indexData;
    }

    dbgstrm << "no more entry." << endl;
    return NULL;
}

netsnmp_variable_list *GetNext(void **loopContext,
    void **dataContext,
    netsnmp_variable_list *indexData,
    netsnmp_iterator_info *data)
{
    uint32_t hostIp = (int32_t)(*loopContext);
    TrapCfgEntry entry;

    dbgstrm << "Start." << endl;
    if (GetNextTrapHost(hostIp, &entry) && entry.trapHostIpAddr != 0)
    {
        dbgstrm << "hostIp = " << InetToString(entry.trapHostIpAddr) << endl;
        snmp_set_var_typed_integer(indexData, ASN_IPADDRESS, entry.trapHostIpAddr);
        *dataContext = (void *)entry.trapHostIpAddr;
        *loopContext = (void *)entry.trapHostIpAddr;
        return indexData;
    }

    dbgstrm << "no more entry." << endl;
    return NULL;
}

void GetHostIpAddr(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* data)
{
    TrapCfgEntry* entry = (TrapCfgEntry*)data;
    dbgstrm << "IpAddr = " << InetToString(entry->trapHostIpAddr) << endl;
    snmp_set_var_typed_integer(request.requestvb, ASN_IPADDRESS,
        entry->trapHostIpAddr);
}

void GetHostSnmpVer(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* data)
{
    TrapCfgEntry* entry = (TrapCfgEntry*)data;
    dbgstrm << entry->trapHostSnmpVer << endl;
    snmp_set_var_typed_integer(request.requestvb, ASN_INTEGER,
            entry->trapHostSnmpVer);
}

void GetHostCommunity(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* data)
{
    TrapCfgEntry* entry = (TrapCfgEntry*)data;
    dbgstrm << entry->trapHostCommunity << endl;
    snmp_set_var_typed_value(request.requestvb, ASN_OCTET_STR,
            entry->trapHostCommunity, strlen(entry->trapHostCommunity));
}

void GetHostIsGosNmsServer(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* data)
{
    TrapCfgEntry* entry = (TrapCfgEntry*)data;
    dbgstrm << entry->trapHostIsGosNmsSever << endl;
    snmp_set_var_typed_integer(request.requestvb, ASN_INTEGER,
        entry->trapHostIsGosNmsSever);
}

void GetHostRowStatus(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* data)
{
    snmp_set_var_typed_integer(request.requestvb, ASN_INTEGER, RS_ACTIVE);
}

void GetTrapHostEventType(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* data)
{
    dbgstrm << "Start." << endl;
    uchar_t value[4] = {1,0,0,0};
    snmp_set_var_typed_value(request.requestvb, ASN_OCTET_STR, value, 4);
}

void GetTrapHostMinEventLevel(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* data)
{
    TrapCfgEntry* entry = (TrapCfgEntry*)data;
    dbgstrm << entry->trapHostMinEventLevel << endl;
    snmp_set_var_typed_integer(request.requestvb, ASN_INTEGER,
        entry->trapHostMinEventLevel);
}

int Get(netsnmp_mib_handler& handler, netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo, netsnmp_request_info& requests)
{
    netsnmp_request_info *request;
    netsnmp_table_request_info *tableInfo;

    dbgstrm << "Start." << endl;
    for (request = &requests; request != NULL; request = request->next)
    {
        uint32_t hostIp;
        hostIp = (uint32_t) netsnmp_extract_iterator_context(request);
        if ((void*)hostIp == NULL)
        {
            dbgstrm << "hostIp is NULL" << endl;
            netsnmp_set_request_error(&reqInfo, request, SNMP_NOSUCHINSTANCE);
            continue;
        }

        tableInfo = netsnmp_extract_table_info(request);

        dbgstrm << "hostIp = " << InetToString(hostIp)
            << ", tableInfo->colnum = " << tableInfo->colnum << endl;
        map<int, SnmpGetHandler>::iterator iter;
        iter = snmpGetValueHandler.find(tableInfo->colnum);
        if (iter != snmpGetValueHandler.end())
        {
            TrapCfgEntry entry;
            bool ret = FindTrapHost(hostIp, &entry);
            assert(ret);
            iter->second(reqInfo, *request, &entry);
        }
        else
        {
            errstrm << "Error, wrong table column number";
            netsnmp_set_request_error(&reqInfo, request, SNMP_NOSUCHOBJECT);
        }
    }

    return SNMP_ERR_NOERROR;
}

int SetReserve1(netsnmp_mib_handler& handler, netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo, netsnmp_request_info& requests)
{
    return SNMP_ERR_NOERROR;
}

void SetReserve2TrapHostIpAddr(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* index)
{
    uint32_t hostIp = *(uint32_t*)index;
    dbgstrm << InetToString(hostIp) << endl;
}

void SetReserve2TrapHostRowStatus(netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& request, void* index)
{
    TrapCfgEntry entry;
    uint32_t hostIp = *(uint32_t*)index;

    int value = *request.requestvb->val.integer;
    switch (value)
    {
    case RS_CREATEANDGO:
    case RS_CREATEANDWAIT:
        dbgstrm << "Create entry, hostIp = " << InetToString(hostIp) << endl;
        if (FindTrapHost(hostIp, NULL))
        {
            errstrm << "Entry existed before, hostIp = " << hostIp << endl;
            netsnmp_set_request_error(&reqInfo, &request, SNMP_ERR_NOCREATION);
            break;
        }
        entry.trapHostIpAddr = hostIp;
        if (!InsertTrapHost(&entry))
        {
            errstrm << "Can't create new entry, hostIp = " << hostIp << endl;
            netsnmp_set_request_error(&reqInfo, &request, SNMP_ERR_BADVALUE);
            break;
        }

        netsnmp_insert_iterator_context(&request, (void *)hostIp);
        break;

    default:
        break;
    }
}

int SetReserve2(netsnmp_mib_handler& handler, netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo, netsnmp_request_info& requests)
{
    netsnmp_request_info *request;
    netsnmp_table_request_info *tableInfo;
    uint32_t hostIp;

    dbgstrm << "Start." << endl;

    for (request = &requests; request; request = request->next)
    {
        tableInfo = netsnmp_extract_table_info(request);
        hostIp = *tableInfo->indexes->val.integer;

        dbgstrm << "hostIp = " << InetToString(hostIp)
                << ", tableInfo->colnum = " << tableInfo->colnum << endl;
        map<int, SnmpSetReserve2Handler>::iterator iter;
        iter = snmpSetReserve2Handler.find(tableInfo->colnum);
        if (iter != snmpSetReserve2Handler.end())
        {
            iter->second(reqInfo, *request, &hostIp);
        }
        else
        {
            break;
        }
    }
    return SNMP_ERR_NOERROR;
}

int SetFree(netsnmp_mib_handler& handler, netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo, netsnmp_request_info& requests)
{
    netsnmp_request_info *request;
    netsnmp_table_request_info *tableInfo;

    uint32_t hostIp;

    dbgstrm << "Start." << endl;

    for (request = &requests; request; request = request->next)
    {
        hostIp = (uint32_t) netsnmp_extract_iterator_context(request);
        if ((void*)hostIp == NULL)
        {
            dbgstrm << "hostIp is NULL" << endl;
            netsnmp_set_request_error(&reqInfo, request, SNMP_NOSUCHINSTANCE);
            break;
        }
        dbgstrm << "index information: " << hostIp << endl;

        tableInfo = netsnmp_extract_table_info(request);
        switch (tableInfo->colnum)
        {
        case ColGsDslTrapHostRowStatus:
            switch (*request->requestvb->val.integer)
            {
            case RS_CREATEANDGO:
            case RS_CREATEANDWAIT:
                DeleteTrapHost(hostIp);
                break;

            default:
                break;
            }
            break;

        default:
            netsnmp_set_request_error(&reqInfo, request, SNMP_ERR_NOTWRITABLE);
            return SNMP_ERR_NOERROR;
        }
    }
    return SNMP_ERR_NOERROR;
}

int SetAction(netsnmp_mib_handler& handler, netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo, netsnmp_request_info& requests)
{
    return SNMP_ERR_NOERROR;
}

int SetUndo(netsnmp_mib_handler& handler, netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo, netsnmp_request_info& requests)
{
    return SNMP_ERR_NOERROR;
}

int SetCommit(netsnmp_mib_handler& handler, netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo, netsnmp_request_info& requests)
{
    netsnmp_request_info *request;
    netsnmp_table_request_info *tableInfo;

    uint32_t hostIp;

    dbgstrm << "Start." << endl;

    for (request = &requests; request; request = request->next)
    {
        hostIp = (uint32_t) netsnmp_extract_iterator_context(request);
        if ((void*)hostIp == NULL)
        {
            dbgstrm << "hostIp is NULL" << endl;
            netsnmp_set_request_error(&reqInfo, request, SNMP_NOSUCHINSTANCE);
            break;
        }
        dbgstrm << "index information: " << InetToString(hostIp) << endl;

        TrapCfgEntry entry;
        if (!FindTrapHost(hostIp, &entry))
        {
            netsnmp_set_request_error(&reqInfo, request, SNMP_NOSUCHINSTANCE);
            return SNMP_ERR_NOERROR;
        }

        tableInfo = netsnmp_extract_table_info(request);
        switch (tableInfo->colnum)
        {
        case ColGsDslTrapHostIpAddr:
            /* do not let user to modify key field. to modify
             * this field, delete entry then add a new entry.
             */
            break;

        case ColGsDslTrapHostSnmpVer:
            entry.trapHostSnmpVer = *request->requestvb->val.integer;
            UpdateTrapHost(&entry);
            break;

        case ColGsDslTrapHostCommunity:
            strncpy(entry.trapHostCommunity,
                (char*)request->requestvb->val.string, MaxHostCommunitySize);
            UpdateTrapHost(&entry);
            break;

        case ColGsDslTrapHostIsGosNmsServer:
            entry.trapHostIsGosNmsSever = *request->requestvb->val.integer;
            UpdateTrapHost(&entry);
            break;

        case ColGsDslTrapHostRowStatus:
            if (*request->requestvb->val.integer == RS_DESTROY)
            {
                DeleteTrapHost(hostIp);
            }
            break;

        case ColGsDslTrapHostMinEventLevel:
            entry.trapHostMinEventLevel = *request->requestvb->val.integer;
            UpdateTrapHost(&entry);
            break;

        default:
            netsnmp_set_request_error(&reqInfo, request, SNMP_ERR_NOTWRITABLE);
            break;
        }
    }
    return SNMP_ERR_NOERROR;
}

/** handles requests for the gsDslTrapHostTable table */
int SnmpTableHandler(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *regInfo,
    netsnmp_agent_request_info *reqInfo,
    netsnmp_request_info *requests)
{
    map<int, SnmpOperationHandler>::iterator iter;

    dbgstrm << "Start." << endl;
    iter = snmpHandler.find(reqInfo->mode);
    assert(iter != snmpHandler.end());
    iter->second(*handler, *regInfo, *reqInfo, *requests);

    return SNMP_ERR_NOERROR;
}

CxxEndNameSpace /* namespace GsDslTrapHostTable */
CxxEndNameSpace /* namespace Snmp */
