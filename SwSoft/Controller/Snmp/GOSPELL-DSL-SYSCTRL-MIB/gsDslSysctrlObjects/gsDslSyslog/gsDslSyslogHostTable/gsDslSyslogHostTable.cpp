/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.iterate.conf 17695 2009-07-21 12:22:18Z dts12 $
 */
#include "SystemInclude.h"
#include "BcmController.h"

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "Util.h"
#include "Debug.h"
#include "SnmpTypes.h"
#include "SnmpCfgMgt.h"
#include "SystemInfoMgt.h"
#include "gsDslSyslogHostTable.h"

using namespace std;

CxxBeginNameSpace(Snmp)
CxxBeginNameSpace(gsDslSyslogHostTable)

static int Get(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
static int SetReserve1(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
static int SetReserve2(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
static int SetFree(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
static int SetAction(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
static int SetUndo(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);
static int SetCommit(netsnmp_mib_handler&, netsnmp_handler_registration&,
    netsnmp_agent_request_info&, netsnmp_request_info&);

static pair<int, SnmpOperationHandler> handlerPairs[] =
{
    make_pair(MODE_GET, Get),
    make_pair(MODE_SET_RESERVE1, SetReserve1),
    make_pair(MODE_SET_RESERVE2, SetReserve2),
    make_pair(MODE_SET_FREE, SetFree),
    make_pair(MODE_SET_ACTION, SetAction),
    make_pair(MODE_SET_UNDO, SetUndo),
    make_pair(MODE_SET_COMMIT, SetCommit)
};
static map<int, SnmpOperationHandler> snmpHandler(handlerPairs, handlerPairs + 7);

/* Initialize the gsDslSyslogHostTable table
 * by defining its contents and how it's structured
 */
void InitGsDslSyslogHostTable(void)
{
    const oid tableOid[] = {1,3,6,1,4,1,22764,7900,3,1,13,2};
    const size_t oidLen  = OID_LENGTH(tableOid);
    netsnmp_handler_registration    *reg;

    reg = netsnmp_create_handler_registration("gsDslSyslogHostTable",
        SnmpTableHandler, tableOid, oidLen,
        HANDLER_CAN_RWRITE);

    netsnmp_table_registration_info *tableInfo;
    tableInfo = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(tableInfo, ASN_IPADDRESS, 0);
    tableInfo->min_column = ColGsDslSsyslogHostIpAddr;
    tableInfo->max_column = ColGsDslSyslogHostRowStatus;
    
    netsnmp_iterator_info *iinfo;
    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
    iinfo->get_first_data_point = GetFirst;
    iinfo->get_next_data_point  = GetNext;
    iinfo->free_data_context = FreeData;
    iinfo->free_loop_context_at_end = FreeLoopAtEnd;
    iinfo->table_reginfo        = tableInfo;
    
    netsnmp_register_table_iterator(reg, iinfo);
}

/* maybe, there is a bug within net-snmp lib.  when add a new row,
 * net-snmp call our FreeData 2 times for the same row, and then cause
 * the process crash.
 * to work around, we record the all pointers which need free. every
 * times, we check the records to avoid free a single pointer twice.
 */
list<void*> dataPointers;

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *GetFirst(void **loopContext,
    void **dataContext,
    netsnmp_variable_list *indexData,
    netsnmp_iterator_info *data)
{
    BASE_ErrCode ret;
    SyslogServer server;

    ret = GetFirstSyslogServer(&server);
    if (ret == BASE_OK)
    {
        *loopContext = new uint32_t(server.addr.s_addr);
        *dataContext = new uint32_t(server.addr.s_addr);
        dataPointers.push_back(*dataContext);

        dbgstrm << "OK."
                << InetToString(server.addr.s_addr)
                << ", " << (int)*dataContext << endl;
        snmp_set_var_typed_integer(indexData, ASN_IPADDRESS,
            server.addr.s_addr);

        return indexData;
    }

    return NULL;
}

netsnmp_variable_list *GetNext(void **loopContext,
    void **dataContext,
    netsnmp_variable_list *indexData,
    netsnmp_iterator_info *data)
{
    BASE_ErrCode ret;
    uint32_t* ip = (uint32_t*)*loopContext;
    SyslogServer server;

    server.addr.s_addr = *ip;
    ret = GetNextSyslogServer(&server, &server);
    if (ret == BASE_OK)
    {
        *ip = server.addr.s_addr;
        *dataContext = new uint32_t(server.addr.s_addr);
        dataPointers.push_back(*dataContext);

        dbgstrm << "OK."
                << InetToString(server.addr.s_addr)
                << ", " << (int)*dataContext << endl;
        snmp_set_var_typed_integer(indexData, ASN_IPADDRESS,
            server.addr.s_addr);

        return indexData;
    }

    return NULL;
}

void FreeData(void *dataContext, struct netsnmp_iterator_info_s *)
{
    dbgstrm << "Start." << (int)dataContext<< endl;
    list<void*>::iterator iter;

    iter = find(dataPointers.begin(), dataPointers.end(), dataContext);
    if (iter != dataPointers.end())
    {
        dbgstrm << InetToString(*(uint32_t*)dataContext) << endl;
        dataPointers.erase(iter);
        delete (uint32_t*)dataContext;
    }
}

void FreeLoopAtEnd(void *loopContext, struct netsnmp_iterator_info_s *)
{
    dbgstrm << "Start." << endl;
    if (loopContext != NULL)
    {
        delete (uint32_t*)loopContext;
    }
}

int Get(netsnmp_mib_handler& handler,
    netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& requests)
{
    netsnmp_request_info *request;
    netsnmp_table_request_info *tableInfo;

    for (request = &requests; request != NULL; request = request->next)
    {
        SyslogServer server;
        uint32_t *ip = (uint32_t*) netsnmp_extract_iterator_context(request);
        if (ip == NULL)
        {
            netsnmp_set_request_error(&reqInfo, request, SNMP_NOSUCHOBJECT);
            continue;
        }
        server.addr.s_addr = *ip;
        if (FindSyslogServer(&server) != BASE_OK)
        {
            netsnmp_set_request_error(&reqInfo, request, SNMP_NOSUCHOBJECT);
            continue;
        }

        tableInfo = netsnmp_extract_table_info(request);

        dbgstrm << "colnum = " << tableInfo->colnum << endl;
        switch (tableInfo->colnum)
        {
        case ColGsDslSsyslogHostIpAddr:
            snmp_set_var_typed_integer(request->requestvb,
                ASN_IPADDRESS, server.addr.s_addr);
            break;

        case ColGsDslSyslogDesPort:
            snmp_set_var_typed_integer(request->requestvb,
                ASN_INTEGER, server.port);
            break;

        case ColGsDslSyslogHostRowStatus:
            snmp_set_var_typed_integer(request->requestvb,
                ASN_INTEGER, RS_ACTIVE);
            break;

        default:
            netsnmp_set_request_error(&reqInfo, request, SNMP_NOSUCHOBJECT);
            break;
        }
    }
    return SNMP_ERR_NOERROR;
}

int SetReserve1(netsnmp_mib_handler& handler,
    netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& requests)
{
    return SNMP_ERR_NOERROR;
}

int SetReserve2(netsnmp_mib_handler& handler,
    netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& requests)
{
    netsnmp_table_request_info *tableInfo;
    netsnmp_request_info *request;

    for (request = &requests; request; request = request->next)
    {
        SyslogServer server;

        tableInfo = netsnmp_extract_table_info(request);
        server.addr.s_addr = *tableInfo->indexes->val.integer;

        if (tableInfo->colnum != ColGsDslSyslogHostRowStatus)
            continue;

        int value = *request->requestvb->val.integer;
        switch (value)
        {
        case RS_CREATEANDGO:
        case RS_CREATEANDWAIT:
            dbgstrm << "Create entry, hostIp = "
                    << InetToString(server.addr.s_addr)
                    << endl;
            if (FindSyslogServer(&server) == BASE_OK)
            {
                errstrm << "Entry existed before, ip = "
                        << InetToString(server.addr.s_addr)
                        << endl;
                netsnmp_set_request_error(&reqInfo, request, SNMP_ERR_NOCREATION);
                break;
            }

            if (AddSyslogServer(&server) != BASE_OK)
            {
                errstrm << "Can't create new entry, hostIp = "
                        << InetToString(server.addr.s_addr) << endl;
                netsnmp_set_request_error(&reqInfo, request, SNMP_ERR_BADVALUE);
                break;
            }

            netsnmp_insert_iterator_context(request, new uint32_t(server.addr.s_addr));
            break;

        default:
            break;
        }
    }
    return SNMP_ERR_NOERROR;
}

int SetFree(netsnmp_mib_handler& handler,
    netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& requests)
{
    return SNMP_ERR_NOERROR;
}

int SetAction(netsnmp_mib_handler& handler,
    netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& requests)
{
    return SNMP_ERR_NOERROR;
}

int SetUndo(netsnmp_mib_handler& handler,
    netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& requests)
{
    return SNMP_ERR_NOERROR;
}

int SetCommit(netsnmp_mib_handler& handler,
    netsnmp_handler_registration& regInfo,
    netsnmp_agent_request_info& reqInfo,
    netsnmp_request_info& requests)
{
    netsnmp_request_info *request;
    netsnmp_table_request_info *tableInfo;

    dbgstrm << "Start." << endl;

    for (request = &requests; request; request = request->next)
    {
        SyslogServer server;
        tableInfo = netsnmp_extract_table_info(request);
        server.addr.s_addr = *tableInfo->indexes->val.integer;

        switch (tableInfo->colnum)
        {
        case ColGsDslSyslogDesPort:
            server.port = *request->requestvb->val.integer;
            UpdateSyslogServer(&server);
            break;

        case ColGsDslSyslogHostRowStatus:
            if (*request->requestvb->val.integer == RS_DESTROY)
            {
                DelSyslogServer(server.addr);
            }
            break;

        default:
            netsnmp_set_request_error(&reqInfo, request, SNMP_ERR_NOTWRITABLE);
            break;
        }
    }
    return SNMP_ERR_NOERROR;
}

/** handles requests for the gsDslSyslogHostTable table */
int SnmpTableHandler(netsnmp_mib_handler *handler,
    netsnmp_handler_registration *regInfo,
    netsnmp_agent_request_info *reqInfo,
    netsnmp_request_info *requests)
{
    map<int, SnmpOperationHandler>::iterator iter;

    dbgstrm << "Start." << endl;
    iter = snmpHandler.find(reqInfo->mode);
    assert(iter != snmpHandler.end());
    iter->second(*handler, *regInfo, *reqInfo, *requests);

    dbgstrm << "memory size = " << dataPointers.size() << endl;
    return SNMP_ERR_NOERROR;
}

CxxEndNameSpace /* namespace gsDslSyslogHostTable */
CxxEndNameSpace /* namespace Snmp */
